# C# 线程同步——事件等待句柄（EventWaitHandle）

使用事件等待句柄（EventWaitHandle）发送信号。

`Mutex`、`Semaphore`和`EventWaitHandle`类都派生自`WaitHandle`基类，所以先介绍下WaitHandle抽象类。

- WaitHandle
  - EventWaitHandle
    - System.Threading.ManualResetEvent
    - System.Threading.AutoResetEvent
  - Semaphore
  - Mutex



## WaitHandle抽象类

`WaitHandle`是一个抽象基类，用于等待一个信号的设置。可以等待不同的信号，因为`WaitHandle`是一个基类，可以从中派生一些其他类。

上述中的`Mutex`、`Semaphore`和`EventWaitHandle`类都派生自`WaitHandle`基类。

异步委托的`BeginInvoke()`方法返回一个实现了`IAsycResult`接口的对象。使用`IAsycResult`接口，可以用`AsycWaitHandle`属性访问`WaitHandle`基类。在调用`WaitHandle`的`WaitOne()`方式或者超时发生是，线程会等待接收一个与等待句柄相关的信号。调用`EndInvoke()`方法，线程最终会阻塞，知道得到结果为止。

示例如下：

```c#
static int TakesAWhile(int x,int ms)
{
    Task.Delay(ms).Wait();
    return 42;
}
delegate int TakesAWhileDelegate(int x, int ms);
public static void Run()
{
    TakesAWhileDelegate d1 = TakesAWhile;
    IAsyncResult ar= d1.BeginInvoke(1, 3000, null, null);
    while (true)
    {
        if (ar.AsyncWaitHandle.WaitOne(50))
        {
            Console.WriteLine("Can get the result now");
            break;
        }
    }
    int result = d1.EndInvoke(ar);
    Console.WriteLine("result:"+result);
}
```

调用上述方法，输出结果如下：

```
Can get the result now
result:42
-----程序执行完毕-----
```

> 使用`WaitHandle`基类可以等待一个信号的出现（`WaitOne()`方法）、等待必须发出信号的多个对象（`WaitAll()`方法），或者等待多个对象中的一个（`WaitAny()`方法）。`WaitAll()`和`WaitAny()`是`WaitHandle`类的静态方法，接收一个`WaitHandle`参数数组。
>
> `WaitHandle`基类有一个`SafeWaitHandle`属性，其中可以将一个本机句柄赋予一个操作系统资源，并等待该句柄。例如，可以指定一个`SafeFileHandle`等待文件I/O操作的完成。

因为`Mutex`、`EventWaitHandle`和`Semaphore`类派生自`WaitHandle`基类，所以可以在等待时使用它们。

EventWaitHandle和上文中的Mutex、Semaphore都派生自WaitHandle抽象类。

```csharp
public class EventWaitHandle : System.Threading.WaitHandle
```

EventWaitHandle又派生出两个子类：

- [System.Threading.AutoResetEvent](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=net-6.0)
- [System.Threading.ManualResetEvent](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.manualresetevent?view=net-6.0)

事件等待句柄有三种实现：

- AutoResetEvent
- ManualResetEvent(Slim)
- CountdownEvent

前两种基于通用的EventWaitHandle类，它们继承了基类的所有功能。



## 自动线程通知（AutoRestEvent）

AutoResetEvent就像验票机的闸门一样：插入一张票据只允许一个人通过。其名称中的Auto指的是开放的闸机在行人通过后会自动关闭或重置。（微软文档：表示线程同步事件在一个等待线程释放后收到信号时自动重置。）

线程可以调用WaitOne方法在闸机门口等待、阻塞（在闸机前等待，直至闸机开启）；

调用Set方法即向闸机中插入一张票据。

如果有一系列的线程调用了WaitOne，那么它们会在闸机后排队等待。

票据可以来自任何线程，即任何一个能够访问AutoResetEvent对象的非阻塞线程都可以调用Set方法来释放一个阻塞的线程。

可以通过调用其本身的构造函数或其父类EventWaitHandle的构造函数，这两种方式来创建AutoResetEvent对象。

```csharp
var auto = new AutoResetEvent(false);
```

如果在构造器中的参数指定为true，表示立即调用Set方法。

```csharp
var auto = new EventWaitHandle(false, EventResetModel.AutoRest);
```

AutoResetEvent常用方法：

- `WaitOne()` 用来等待另一个线程发送通知。接受一个可选的超时参数，如果在超时时间内没有收到信号，则返回false。可以使用0作为超时时间调用WaitOne来确认一个等待句柄是否处于“开放”状态，并且不会造成调用者阻塞，如果此时AutoResetEvent处于开放状态的话会将状态重置。
- Set()：用来对线程发出通知，插入票据；
- `ReSet()` 用来重置 `AutoResetEvent` 状态；可以无须等待或阻塞就关闭闸机的门（若原本处于开启状态的话）。



示例一，当线程启动后等待另一个线程发送通知：

```c#
EventWaitHandle _waitHandle = new AutoResetEvent(false);
new Thread(() =>
{
    Console.WriteLine("等待中...");
    _waitHandle.WaitOne();                // Wait for notification
    Console.WriteLine("收到通知");
}).Start();

//Thread.Sleep(1000);                  // Pause for a second...
Console.WriteLine("按下回车键发送通知");
Console.ReadLine();
_waitHandle.Set();
Console.ReadLine();
```

==注意：正常情况下，应该是先有人排队再插入票据，也就是说先调用了WaitOne方法，再调用Set方法，但不是强制要求一定要这么做。在没有任何线程等待的情况下调用Set方法会导致句柄一直处于打开状态，直至有线程调用WaitOne方法。另外，在一个没有线程等待的闸机对象上多次重复调用Set方法，并不会导致多个到达的线程一次性都通过，而是只有下一个线程可以通过，而其他的票据（Set方法）就被浪费了。==

示例二，使用多个AutoResetEvent实现双向信号，主线程等待工作线程准备就绪之后再发送信号：

```csharp
private static void TwoWaySignaling()
{
    EventWaitHandle _ready = new AutoResetEvent(false);
    EventWaitHandle _go = new AutoResetEvent(false);
    object _locker = new object();
    string _message = "";

    new Thread(() =>
    {
        while (true)
        {
            //表示我们已经准备好了
            _ready.Set();
            //等待通知
            _go.WaitOne();
            lock (_locker)
            {
                //使用null消息来停止工作线程的运行
                if (_message == null) return;
                Console.WriteLine(_message);
            }
        }
    }).Start();
    //先等到工人准备好
    _ready.WaitOne();
    lock (_locker) _message = "ooo";
    _go.Set();

    _ready.WaitOne();
    lock (_locker) _message = "ahhh";  // Give the worker another message
    _go.Set();

    _ready.WaitOne();
    lock (_locker) _message = null;    // Signal the worker to exit
    _go.Set();
}
```



## 手动线程通知（ManualResetEvent，信号发送结构）

AutoResetEvent 和 ManualResetEvent 十分相似。两者之间的区别，在于前者是自动(Auto)，后者是手动(Manua)。

ManualResetEvent 的作用就像是一个大门。

调用Set方法就开启大门；

并允许任意数目的调用了WaitOne方法的线程通过大门；

而调用Reset方法则会关闭大门。

在大门关闭时调用WaitOne方法会发生阻塞，而当大门再次打开时，线程会立刻释放。

除了这些区别之外，ManualRestEvent的功能和AutoResetEvent是一样的。

ManualResetEvent适用于用一个线程来释放其他所有线程的情形，门一旦开启，其他线程都可以通过。

示例：

```csharp
class Program
{
    private static ManualResetEvent resetEvent = new ManualResetEvent(false);
    static void Main(string[] args)
    {
        new Thread(DoOne).Start();
        // 用于不断向另一个线程发送信号
        while (true)
        {
            Console.ReadKey();
            resetEvent.Set();           // 发生通知，设置终止状态
        }
    }

    public static void DoOne()
    {
        Console.WriteLine("等待中，请发出信号允许我运行");
        resetEvent.WaitOne();

        // 后面的都无效，线程会直接跳过而无需等待
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        Console.WriteLine("线程结束");
    }
}
```

#### ManualResetEventSlim

.NET 4.0 引入了一种新的 ManualResetEvent称为 ManualResetEventSlim。后者对短时期的等待进行了优化。即选择进行几个迭代的自旋操作。此外，它还拥有更加高效的托管实现。并支持在Wait时使用CancellationToken取消等待操作。但是它不能进行跨进程的信号发送。ManualResetEventSlim并没有从WaitHandle中派生，但是它拥有一个WaitHandle属性，访问该属性将返回一个（使用传统等待句柄性能配置的）WaitHandle派生类型的对象。



## 线程完成数（CountdownEvent，信号发送结构）

ManualResetEvent适用于用一个线程来释放其他所有线程的情形，而CountdownEvent则适用于其相反的情形。

CountdownEvent 可用于等待多个线程。若使用该类，需要在实例化时指定线程数目或者需要等待的线程“计数”。

```c#
var  countdown = new CountdownEvent (3);
```

调用 Signal 会使计数递减，而调用 Wait 则会阻塞，直至计数减为零。

调用AddCount方法可以重新增加CountdownEvent的计数，但是如果它的计数已经降为0，则调用该方法会抛出异常：我们无法通过调用AddCount来取消CountdownEvent的信号。为了避免抛出异常，还可以使用TryAddCount，若计数值为0，则该方法返回false。

调用Reset方法可以取消计数事件的信号：它不但取消信号，而且会将计数值重置为原始设定值。

```c#
//等待三个线程
static CountdownEvent _countdown = new CountdownEvent(3);
static void Main(string[] args)
{
    new Thread(SaySomething).Start("第一个线程");
    new Thread(SaySomething).Start("第二个线程");
    new Thread(SaySomething).Start("第三个线程");
    //等待CountdownEvent的计数清零
    _countdown.Wait();   // Blocks until Signal has been called 3 times
    Console.WriteLine("所有的线程都结束运行!");
    Console.ReadLine();
}
static void SaySomething(object thing)
{
    Console.WriteLine(thing);
    Console.ReadLine();
    Console.WriteLine(thing + "按下回车键结束运行");
    // 通知可以减少一个线程的等待了将CountdownEvent计数减一
    _countdown.Signal();
}
```

注意：优先使用PLINQ和Parallel类，再使用CountdownEvent。



### 信号发送结构的性能

- 在无阻塞的情况下，等待或激活一个AutoResetEvent 或者 ManualResetEvent对象需要消耗一微秒的时间。
- 在短暂的等待中，ManualResetEventSlim 和 CountdownEvent的速度要快50倍，因为他们不依赖操作系统，并且谨慎的使用了自旋结构。
- 在大多数情况下，信号发送类本身的开销并不会形成瓶颈，因此很少需要特意进行考虑。



## AutoResetEvent 和 ManualResetEvent 区别（待整理）

ManualResetEvent 发送信号后，信号状态会设置为True，也就是此时程序只要执行到WaitOne()就会接收到信号，只有调用Reset的时候信号状态才会被设置为False 。而AutoResetEvent调用WaitOne将信号状态会设置为True后会自动调用Reset，将非信号状态立即设置为False，如果此时有WaitOne函数在等待信号，则会执行，之后的WaitOne则不会接收到信号。

概括来说，Manual与Auto的区别主要在于：

1. 如果有多个线程都在用WaitOne等待信号量，那么每次Set()，auto只会释放一个WaitOne，而manual会全部释放
2. 调用WaitOne后，auto会自动调用Reset()方法，而manual则会保持开放



ManualResetEvent在创建的时候可以设置信号状态

 ManualResetEvent manualResetEvent = new ManualResetEvent(false); 

ManualResetEvent.WaitOne()作用是等待信号到达，如果没有信号就会让线程再此等待，简单说就是信号状态为True的时候才会继续执行，信号状态为False时，线程会卡在这里 

ManualResetEvent.Set() 发就是将信号状态设置为true，也就是会让WaitOne能够接受信号 ManualResetEvent.Reset()，将信号状态设置为False，也就是设置为非信号状态 





## 并行协调（Barrier ，信号发送结构）

Barrier类实现了一个线程执行屏障（thread execution Barrier），Barrier允许多个线程在同一时刻汇合，使得多个线程有序同步完成多个阶段的任务。

对于同步，`Barrier`类非常适用于其中工作有多个任务分支且以后又需要合并工作的情况。`Barrier`类用于需要同步的参与者。激活一个任务时，就可以动态的添加其他参与者。

`Barrier`类型提供了一个更复杂的场景，其中可以同时运行多个任务，直到达到一个同步点为止。一旦所有任务达到这一点，他们j就可以继续同时满足于下一个同步点。

应用场景主要是控制 N 个线程(可随时增加或减少执行的线程)，使得多线程在能够在 M 个阶段中保持同步。

示例，实现3个线程都会打印从0到4的数字，并与其他线程保持步调一致：

```csharp
static Barrier _barrier = new Barrier(3, barrier => Console.WriteLine());
static void Speak()
{
    for (int i = 0; i < 5; i++)
    {
        Console.Write(i + " ");
        _barrier.SignalAndWait();
    }
}
static void Main(string[] args)
{
    new Thread(Speak).Start();
    new Thread(Speak).Start();
    new Thread(Speak).Start();
}
```

![image-20240301102731503](./assets/image-20240301102731503.png)

上述代码中，使用3作为参数创建Barrier实例，则需要调用3次SignalAndWait方法才能够解除阻塞。

在阻塞解除之后它会重新“轮回”：即再次调用SignalAndWait方法会令其重新进入阻塞状态，而这个阻塞状态需要再调用3次SignalAndWait才能解除。这样就可以令各个线程都步调一致的执行。

创建Barrier对象时还可以指定一个后续操作，该操作是一个委托，==它会在SignalAndWait调用n次之后，所有线程释放之前执行==。



----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [2. 线程同步 · C# 多线程与异步](https://threads.whuanle.cn/2.thread_sync/)

Last updated：2025-08-31





