# C# 线程同步——事件等待句柄（EventWaitHandle）

使用事件等待句柄（EventWaitHandle）从一个线程向另一个线程发送信号，线程在收到该信号的通知后，继续本身的工作，否则就等待线程的信号。

通过该对象可以实现线程排队功能。

`Mutex`、`Semaphore`和`EventWaitHandle`类都派生自`WaitHandle`基类，所以先介绍下WaitHandle抽象类。

- WaitHandle
  - EventWaitHandle
    - System.Threading.ManualResetEvent
    - System.Threading.AutoResetEvent
  - Semaphore
  - Mutex



## WaitHandle 抽象类

[WaitHandle 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle?view=netframework-4.8)

`WaitHandle`是一个抽象基类，用于等待一个信号的设置。可以等待不同的信号，因为`WaitHandle`是一个基类，可以从中派生一些其他类。

上述中的`Mutex`、`Semaphore`和`EventWaitHandle`类都派生自`WaitHandle`基类。

异步委托的`BeginInvoke()`方法返回一个实现了`IAsycResult`接口的对象。使用`IAsycResult`接口，可以用`AsycWaitHandle`属性访问`WaitHandle`基类。在调用`WaitHandle`的`WaitOne()`方式或者超时发生是，线程会等待接收一个与等待句柄相关的信号。调用`EndInvoke()`方法，线程最终会阻塞，知道得到结果为止。

示例如下：

```c#
static int TakesAWhile(int x,int ms)
{
    Task.Delay(ms).Wait();
    return 42;
}
delegate int TakesAWhileDelegate(int x, int ms);
public static void Run()
{
    TakesAWhileDelegate d1 = TakesAWhile;
    IAsyncResult ar= d1.BeginInvoke(1, 3000, null, null);
    while (true)
    {
        if (ar.AsyncWaitHandle.WaitOne(50))
        {
            Console.WriteLine("Can get the result now");
            break;
        }
    }
    int result = d1.EndInvoke(ar);
    Console.WriteLine("result:"+result);
}
```

调用上述方法，输出结果如下：

```
Can get the result now
result:42
-----程序执行完毕-----
```

> 使用`WaitHandle`基类可以等待一个信号的出现（`WaitOne()`方法）、等待必须发出信号的多个对象（`WaitAll()`方法），或者等待多个对象中的一个（`WaitAny()`方法）。`WaitAll()`和`WaitAny()`是`WaitHandle`类的静态方法，接收一个`WaitHandle`参数数组。
>
> `WaitHandle`基类有一个`SafeWaitHandle`属性，其中可以将一个本机句柄赋予一个操作系统资源，并等待该句柄。例如，可以指定一个`SafeFileHandle`等待文件I/O操作的完成。

因为`Mutex`、`EventWaitHandle`和`Semaphore`类派生自`WaitHandle`基类，所以可以在等待时使用它们。



## EventWaitHandle 类

[EventWaitHandle 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.eventwaithandle?view=netframework-4.8)

EventWaitHandle和上文中的Mutex、Semaphore都派生自WaitHandle抽象类。

```csharp
public class EventWaitHandle : System.Threading.WaitHandle
```

### EventWaitHandle 的常用方法

- [Reset()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.eventwaithandle.reset?view=netframework-4.8#system-threading-eventwaithandle-reset)：将事件状态设置为非终止状态，导致线程阻止。
- [Set()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.eventwaithandle.set?view=netframework-4.8#system-threading-eventwaithandle-set)：将事件状态设置为终止状态，允许一个或多个等待线程继续。
- [WaitOne(TimeSpan, Boolean)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitone?view=netframework-4.8#system-threading-waithandle-waitone(system-timespan-system-boolean))：阻止当前线程，直到当前实例收到信号为止，同时使用 TimeSpan 指定时间间隔，并指定是否在等待之前退出同步域。

EventWaitHandle又派生出两个子类：

- [System.Threading.AutoResetEvent](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=net-6.0)
- [System.Threading.ManualResetEvent](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.manualresetevent?view=net-6.0)



## AutoRestEvent 类

作用：从一个线程A向另一个线程B发送通知，线程B只有在接收到该通知后，才继续工作。发送通知的线程可以是多个不同的线程。即任何一个能够访问AutoResetEvent对象的非阻塞线程都可以调用Set方法来释放一个阻塞的线程。

> 所谓发送通知，其实是一个信号状态，AutoRestEvent和ManualResetEvent相关的方法，本质上是对该信号状态进行改变，从而实现通知目的。

可以通过调用其本身的构造函数或其父类EventWaitHandle的构造函数，这两种方式来创建AutoResetEvent对象。

```csharp
var auto = new AutoResetEvent(false);
```

如果在构造器中的参数指定为true，表示立即调用Set方法。

```csharp
var auto = new EventWaitHandle(false, EventResetModel.AutoRest);
```

AutoResetEvent 常用方法：

- `WaitOne()` 用来阻塞线程，直到等待的线程收到另一个线程发送通知。接受一个可选的超时参数，如果在超时时间内没有收到信号，则返回false。可以使用0作为超时时间调用WaitOne来确认一个等待句柄是否处于“开放”状态，并且不会造成调用者阻塞，如果此时AutoResetEvent处于开放状态的话会将状态重置。
- Set()：用来释放线程，类似于对线程发出通知，允许一个或多个等待的线程继续工作。
- `ReSet()` 用来重置 `AutoResetEvent` 状态。

可以把AutoResetEvent 看作是一道自动上锁的门，这个锁就是信号，锁的开关就是信号状态。至于这个门一开始有没有上锁，可以在创建AutoResetEvent 实例时指定initialState的值。当一个线程调用WaitOne()方法就相当于一个人走到了这道门前，如果门是锁着的，就得等待开门（阻塞线程）。如果门没锁，就可以直接通过（线程继续执行）。当门锁着时，需要等待其他线程中调用Set()方法来更改信号状态，让门上的锁处于打开的状态，此时被阻塞的线程就可以通过从而继续工作。ReSet()方法相当于重新把门关上，在AutoResetEvent中，这个是自动完成的。

### AutoResetEvent 实战

示例一，当线程启动后等待另一个线程发送通知：

```c#
EventWaitHandle _waitHandle = new AutoResetEvent(false);
new Thread(() =>
{
    Console.WriteLine("等待中...");
    _waitHandle.WaitOne();                // Wait for notification
    Console.WriteLine("收到通知");
}).Start();

//Thread.Sleep(1000);                  // Pause for a second...
Console.WriteLine("按下回车键发送通知");
Console.ReadLine();
_waitHandle.Set();
Console.ReadLine();
```

==注意：正常情况下，应该是先有人排队再插入票据，也就是说先调用了WaitOne方法，再调用Set方法，但不是强制要求一定要这么做。在没有任何线程等待的情况下调用Set方法会导致句柄一直处于打开状态，直至有线程调用WaitOne方法。另外，在一个没有线程等待的闸机对象上多次重复调用Set方法，并不会导致多个到达的线程一次性都通过，而是只有下一个线程可以通过，而其他的票据（Set方法）就被浪费了。==

示例二，使用多个AutoResetEvent实现双向信号，主线程等待工作线程准备就绪之后再发送信号：

```csharp
private static void TwoWaySignaling()
{
    EventWaitHandle _ready = new AutoResetEvent(false);
    EventWaitHandle _go = new AutoResetEvent(false);
    object _locker = new object();
    string _message = "";

    new Thread(() =>
    {
        while (true)
        {
            //表示我们已经准备好了
            _ready.Set();
            //等待通知
            _go.WaitOne();
            lock (_locker)
            {
                //使用null消息来停止工作线程的运行
                if (_message == null) return;
                Console.WriteLine(_message);
            }
        }
    }).Start();
    //先等到工人准备好
    _ready.WaitOne();
    lock (_locker) _message = "ooo";
    _go.Set();

    _ready.WaitOne();
    lock (_locker) _message = "ahhh";  // Give the worker another message
    _go.Set();

    _ready.WaitOne();
    lock (_locker) _message = null;    // Signal the worker to exit
    _go.Set();
}
```



## ManualResetEvent 类

[ManualResetEvent 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.manualresetevent?view=netframework-4.8)

ManualResetEvent 和上文中的AutoResetEvent 的用法十分相似。

- ManualResetEvent.WaitOne()：作用是等待信号到达，如果没有信号就会让线程再此等待，简单说就是信号状态为True的时候才会继续执行，信号状态为False时，线程会卡在这里 。
- ManualResetEvent.Set() ：就是将信号状态设置为true，也就是会让WaitOne能够接受信号 ManualResetEvent.Reset()，将信号状态设置为False，也就是设置为非信号状态 。

ManualResetEvent  和 AutoResetEvent  之间的区别主要有：

- AutoResetEvent 在调用 Set() 之后会自动重置信号状态，不需要显式调用Reset()方法，相当于门开了人通过后就自动关上了门，正是因为每次都自动重置，因此一次只能释放一个线程。
- ManualResetEvent在调用Set() 方法时，会保持信号状态，相当于门开了一直没有关，因此它会释放所有的调用了WaitOne()的线程通过，直到手动调用Reset方法关闭门。

ManualResetEvent适用于用一个线程来释放其他所有线程的情形，门一旦开启，在没有显式调用Reset方法时，其他线程都可以通过。

### ManualResetEvent 实战

示例：

```csharp
class Program
{
    private static ManualResetEvent resetEvent = new ManualResetEvent(false);
    static void Main(string[] args)
    {
        new Thread(DoOne).Start();
        // 用于不断向另一个线程发送信号
        while (true)
        {
            Console.ReadKey();
            resetEvent.Set();           // 发生通知，设置终止状态
        }
    }

    public static void DoOne()
    {
        Console.WriteLine("等待中，请发出信号允许我运行");
        resetEvent.WaitOne();

        // 后面的都无效，线程会直接跳过而无需等待
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        Console.WriteLine("线程结束");
    }
}
```



### ManualResetEventSlim

.NET 4.0 引入了一种新的 ManualResetEvent称为 ManualResetEventSlim。后者对短时期的等待进行了优化。即选择进行几个迭代的自旋操作。此外，它还拥有更加高效的托管实现。并支持在Wait时使用CancellationToken取消等待操作。但是它不能进行跨进程的信号发送。ManualResetEventSlim并没有从WaitHandle中派生，但是它拥有一个WaitHandle属性，访问该属性将返回一个（使用传统等待句柄性能配置的）WaitHandle派生类型的对象。



----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [2. 线程同步 · C# 多线程与异步](https://threads.whuanle.cn/2.thread_sync/)

Last updated：2025-08-31





