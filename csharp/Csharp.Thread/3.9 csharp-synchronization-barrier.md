# C#线程同步——Barrier

[Barrier 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.barrier?view=netframework-4.8&devlangs=csharp&f1url=%3FappId%3DDev17IDEF1%26l%3DZH-CN%26k%3Dk(System.Threading.Barrier)%3Bk(TargetFrameworkMoniker-.NETFramework%2CVersion%3Dv4.8)%3Bk(DevLang-csharp)%26rd%3Dtrue)：使多个任务能够采用并行方式依据某种算法在多个阶段中协同工作。

Barrier中文翻译为“屏障”。Barrier类实现了一个线程执行屏障（thread execution Barrier），用于组织多个线程在某个时刻碰面，其提供了一个回调函数，每次线程调用了SignalAndWait方法后该回调函数会被执行。

`Barrier`类型提供了一个更复杂的场景，其中可以同时运行多个任务，直到达到一个同步点为止。一旦所有任务达到这一点，他们j就可以继续同时满足于下一个同步点。

`Barrier`类非常适用于其中工作有多个任务分支且以后又需要合并工作的情况。`Barrier`类用于需要同步的参与者。激活一个任务时，就可以动态的添加其他参与者。

应用场景主要是控制 N 个线程(可随时增加或减少执行的线程)，使得多线程在能够在 M 个阶段中保持同步。

### Barrier 的常用方法

- [AddParticipant()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.barrier.addparticipant?view=netframework-4.8#system-threading-barrier-addparticipant)：通知 Barrier，告知其将会有另一个参与者。
- [AddParticipants(Int32)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.barrier.addparticipants?view=netframework-4.8#system-threading-barrier-addparticipants(system-int32))：通知 Barrier，告知其将会有多个其他参与者。
- [RemoveParticipant()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.barrier.removeparticipant?view=netframework-4.8#system-threading-barrier-removeparticipant)：通知 Barrier，告知其将会减少一个参与者。
- [RemoveParticipants(Int32)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.barrier.removeparticipants?view=netframework-4.8#system-threading-barrier-removeparticipants(system-int32))：通知 Barrier，告知其将会减少一些参与者。
- [SignalAndWait()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.barrier.signalandwait?view=netframework-4.8#system-threading-barrier-signalandwait)：发出参与者已达到屏障并等待所有其他参与者也达到屏障。
- [SignalAndWait(TimeSpan, CancellationToken)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.barrier.signalandwait?view=netframework-4.8#system-threading-barrier-signalandwait(system-timespan-system-threading-cancellationtoken))：发出参与者已达到屏障的信号，并等待所有其他参与者也达到屏障，使用 TimeSpan 对象测量时间间隔，同时观察取消标记。

### Barrier 实战

示例一，实现3个线程都会打印从0到4的数字，并与其他线程保持步调一致：

```csharp
static Barrier _barrier = new Barrier(3, barrier => Console.WriteLine());
static void Speak()
{
    for (int i = 0; i < 5; i++)
    {
        Console.Write(i + " ");
        _barrier.SignalAndWait();
    }
}
static void Main(string[] args)
{
    new Thread(Speak).Start();
    new Thread(Speak).Start();
    new Thread(Speak).Start();
}
```

![image-20240301102731503](E:\Wy_Work\AngYony\ay-net-notes\csharp\Csharp.Thread\assets\image-20240301102731503.png)

上述代码中，使用3作为参数创建Barrier实例，则需要调用3次SignalAndWait方法才能够解除阻塞。

在阻塞解除之后它会重新“轮回”：即再次调用SignalAndWait方法会令其重新进入阻塞状态，而这个阻塞状态需要再调用3次SignalAndWait才能解除。这样就可以令各个线程都步调一致的执行。

创建Barrier对象时还可以指定一个后续操作，该操作是一个委托，==它会在SignalAndWait调用n次之后，所有线程释放之前执行==。

示例二：

```csharp
// 创建一个初始有5个参与者的 Barrier
static Barrier barrier = new Barrier(5, b =>
    Console.WriteLine($"所有参与者已完成第 {b.CurrentPhaseNumber} 阶段的工作"));

static void Work(object threadId)
{
    for (int phase = 1; phase <= 3; phase++) // 假设有三个阶段
    {
        Console.WriteLine($"工作者线程 {threadId} 开始第 {phase} 阶段的工作...");
        // 模拟一些工作...
        Thread.Sleep(100);

        Console.WriteLine($"工作者线程 {threadId} 完成了第 {phase} 阶段的工作...");

        // 等待其他线程完成相同阶段的工作
        barrier.SignalAndWait();
    }
}

static void Main(string[] args)
{
    // 启动五个新线程，每个线程完成工作后都会信号通知 Barrier
    for (int i = 0; i < 5; i++)
    {
        Thread workerThread = new Thread(() => Work(i + 1));
        workerThread.Start();
    }           
     Console.ReadKey();
}
```

