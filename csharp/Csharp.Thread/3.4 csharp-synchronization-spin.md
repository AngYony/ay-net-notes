# C# 线程同步——自旋（SpinWait）与自旋锁（SpinLock）

  

线程阻塞是会耗费上下文切换的，对于过短的线程等待，这种切换的代价会比较昂贵的。在我们前面的示例中，大量使用了 `Thread.Sleep()` 和各种类型的等待方法，这其实是不合理的。

SpinWait 则提供了更好的选择。

自旋和阻塞的区别自旋与阻塞有一些细微的差别。首先，非常短暂的自旋在条件可以很快得到满足的场景（例如几微秒）下是非常高效的，因为它避免了上下文切换带来的延迟和开销。

三种常用的线程等待：

- `Thread.Sleep();` 会阻塞线程，使得线程交出时间片，然后处于休眠状态，直至被重新唤醒；适合用于长时间的等待；
- `Thread.SpinWait();` 使用了自旋等待，等待过程中会进行一些的运算，线程不会休眠，用于微小的时间等待；长时间等待会影响性能；
- `Task.Delay();` 用于异步中的等待，异步的文章后面才写，这里先不理会；

线程等待有内核模式(Kernel Mode)和用户模式(User Model)。

因为只有操作系统才能控制线程的生命周期，因此使用 `Thread.Sleep()` 等方式阻塞线程，发生上下文切换，此种等待称为内核模式。

用户模式使线程等待，并不需要线程切换上下文，而是**让线程通过执行一些无意义的运算，实现等待，也称为自旋**。自旋的意思是，没事找事做。

自旋一次消耗的时间极低，并且 `Thread.Sleep` 会出现上下文切换，而 `Thread.SpinWait` 不会。`Thread.SpinWait` 适合等待短暂的任务，实现线程同步。

`Thread.SpinWait()` 在极少数情况下，避免线程使用上下文切换很有用。

### SpinWait 

SpinWait 是结构体；Thread.SpinWait() 的原理就是 SpinWait 。

属性：

| 属性              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| Count             | 获取已对此实例调用 SpinOnce() 的次数。                       |
| NextSpinWillYield | 获取对 SpinOnce() 的下一次调用是否将产生处理器，同时触发强制上下文切换。 |

方法：

| 方法                      | 说明                                                     |
| ------------------------- | -------------------------------------------------------- |
| Reset()                   | 重置自旋计数器。                                         |
| SpinOnce()                | 执行单一自旋。                                           |
| SpinOnce(Int32)           | 执行单一自旋，并在达到最小旋转计数后调用 Sleep(Int32) 。 |
| SpinUntil(Func)           | 在指定条件得到满足之前自旋。                             |
| SpinUntil(Func, Int32)    | 在指定条件得到满足或指定超时过期之前自旋。               |
| SpinUntil(Func, TimeSpan) | 在指定条件得到满足或指定超时过期之前自旋。               |

`Thread.Sleep()` 会发生上下文切换，出现比较大的性能损失，如果需要等待的时间很短，那就最好使用 `Thread.SpinWait`，让线程继续占用短时间的 CPU 什么也不做，避免出现线程上下文切换。

SpinWait 实质上是（处理器）使用了非常紧密的循环，并使用 `iterations` 参数指定的循环计数。 SpinWait 等待时间取决于处理器的速度。

SpinWait 无法使你准确控制等待时间，主要是使用一些锁时用到，例如 Monitor.Enter。

### SpinLock

微软文档：提供一个相互排斥锁基元，在该基元中，尝试获取锁的线程将在重复检查的循环中等待，直至该锁变为可用为止。

SpinLock 称为自旋锁，适合用在频繁争用而且等待时间较短的场景。主要特征是避免了阻塞，不出现昂贵的上下文切换。

读写锁 ReaderWriterLock 和 ReaderWriterLockSlim ，而 ReaderWriterLockSlim 内部依赖于 SpinLock，并且比 ReaderWriterLock 快了三倍。

`SpinLock`结构的用法非常类似于`Monitor`类。使用`Enter()`或`TryEnter()`方法获得锁，使用`Exit()`方法释放锁定。与`Monitor`相比，如果基于对象的锁定对象（使用`Monitor`）的系统开销由于垃圾回收而过高，就可以使用`SpinLock`结构。如果有大量的锁定，且锁定的时间总是非常短，`SpinLock`结构就很有用。~~应避免使用多个`SpinLock`结构，也不要调用任何可能阻塞的内容。~~

`SpinLock`结构还提供了属性`IsHeld`和`IsHeldByCurrentThread`，指定它当前是否被锁定。

注意：由于`SpinLock`定义为结构，因此传递`SpinLock`实例时，是按照值类型传递的。

SpinLock 的模板如下：

```csharp
private static void DoWork()
{
    SpinLock spinLock = new SpinLock();
    bool isGetLock = false;     // 是否已获得了锁
    try
    {
        spinLock.Enter(ref isGetLock);
        // 运算
    }
    finally
    {
        if (isGetLock)
            spinLock.Exit();
    }
}
```

需要注意的是， SpinLock 实例不能共享，也不能重复使用。

### 自旋与休眠

当线程处于进入休眠状态或解除休眠状态时，会发生上下文切换，这就带来了昂贵的消耗。

而线程不断运行，就会消耗 CPU 时间，占用 CPU 资源。

对于过短的等待，应该使用自旋(spin)方法，避免发生上下文切换；过长的等待应该使线程休眠，避免占用大量 CPU 时间。

我们可以使用最为熟知的 `Sleep()` 方法休眠线程。有很多同步线程的类型，也使用了休眠手段等待线程（已经写好草稿啦）。

自旋的意思是，没事找事做。



## 自旋与阻塞

线程等待有内核模式(Kernel Mode)和用户模式(User Model)。

因为只有操作系统才能控制线程的生命周期，因此使用 `Thread.Sleep()` 等方式阻塞线程，发生上下文切换，此种等待称为内核模式。

用户模式使线程等待，并不需要线程切换上下文，而是让线程通过执行一些无意义的运算，实现等待，也称为自旋。

我们来对比一下 `Thread.Sleep(1)` 和 `Thread.SpinWait(1)` 占用的时间。

```csharp
    static void Main(string[] args)
    {
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();
        Thread.Sleep(1);
        Console.WriteLine(stopwatch.Elapsed.ToString());
        Console.ReadKey();
    }
    static void Main(string[] args)
    {
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();
        Thread.SpinWait(1);
        Console.WriteLine(stopwatch.Elapsed.ToString());
        Console.ReadKey();
    }
```

输出结果：

```
00:00:00.0014747
00:00:00.0000214
```

可以看到，自旋一次消耗的时间远远低于 `1ms`，并且 `Thread.Sleep` 会出现上下文切换，而 `Thread.SpinWait` 不会。`Thread.SpinWait` 适合等待短暂的任务，实现线程同步。

自旋的详细介绍见《线程同步》。





----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [2. 线程同步 · C# 多线程与异步](https://threads.whuanle.cn/2.thread_sync/)

Last updated：2025-08-31





