# C# Task

任务表示将完成的某个工作单元。这个工作单元可以在单独的线程中运行，也可以以同步方式启动一个任务，这需要等待**主调线程**。使用任务不仅可以获得一个抽象层，还可以对底层线程进行很多控制。因此，对于复杂的并行处理，为了更好的控制并行操作，优先使用`Task`类。

现代异步编程的核心是`Task` 和 `Task<T>` 对象，用来代替直接使用线程池的编码。

Task的本质仍然是多线程，Task在大多数情况下会使用线程池中的线程，但并不是一定会使用，Task也可以创建出独立的非线程池中的线程。



## 创建 Task

Task有四种种创建方式：

- new Task() 
- Task.Factory.StartNew() 或 new TaskFactory()
- Task.Run()
- `TaskCompletionSource<TResult>`

要获取任务返回结果，要使用泛型类或方法创建任务，例如 `Task<Tresult>`、`Task.Factory.StartNew<TResult>()`、`Task.Run<TResult>`。

获取Task返回的结果，推荐使用GetAwaiter().getResult()方式获取，注意：不要直接通过 `Result` 属性返回结果，可能会造成死锁。

### new Task() 

通过其构造函数创建一个任务，其构造函数定义为：

```csharp
public Task (Action action);
```

不传递参数：

```csharp
// 1.使用构成函数实例化一个task
var task = new Task(() =>
{
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}");
});
task.Start();
Console.WriteLine($"task.id={task.Id}，task.status={task.Status}");

task.Wait();
Console.WriteLine($"task.id={task.Id}，task.status={task.Status}");

```

传递参数：

```csharp
var task2 = new Task((obj) =>
{
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}，传入的值为：{obj}");
},"张三");
// 同步运行，只有任务运行完成之后，才会输出后续内容
task2.RunSynchronously(); // 等待任务的完成，类似于wait操作

Console.WriteLine($"task.id={task2.Id}，task.status={task2.Status}");
```

`.Start()` 方法用于启动一个任务。微软文档解释：启动 Task，并将它安排到当前的 TaskScheduler 中执行。



### Task.Factory.StartNew()

使用 `Task.Factory`属性用于创建和配置 `Task` 和 `Task<TResult>` 实例的工厂方法。

通过 `Task.Factory.StartNew()` 方法添加的任务，会进入线程池任务队列然后自动执行，不需要手动启动。

无参数：

```csharp
var task3 = Task.Factory.StartNew(()=> {
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}");
});
task3.Wait();
Console.WriteLine($"task.id={task3.Id}，task.status={task3.Status}");
```

传递参数：

```csharp
var task4 = Task.Factory.StartNew((obj) => {
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}，传入的值为：{obj}");
},"张三");
Console.WriteLine($"task.id={task4.Id}，task.status={task4.Status}");
```

使用TaskCreationOptions：

```csharp
Task.Factory.StartNew(() =>
{
    Console.WriteLine("① 开始执行");
    Thread.Sleep(TimeSpan.FromSeconds(1));

    Console.WriteLine("① 执行中");
    Thread.Sleep(TimeSpan.FromSeconds(1));

    Console.WriteLine("① 执行即将结束");
},TaskCreationOptions.LongRunning);
```

除了直接使用`Task`类的静态属性`Factory`来访问`TaskFactory`外，还可以实例化`TaskFactory`类，提供更全面的支持，并调用该实例的`StartNew()`方法，来启动任务。

### Task.Run()

Task.Run适用于不需要传递参数的场景，功能最简单。

```csharp
var task5 = Task.Run(()=> {
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}");
});
```

调用`Task`类的`Run()`静态方法，立即启动任务。虽然`Run()`方法没有可以传递`Action<object>`委托的重载版本，但是可以通过传递`Action`类型的lambda表达式并在其实现中使用参数，可以模拟这种行为。

### `TaskCompletionSource<TResult>`

面提到提到过，创建任务的三种方法：`new Task()`、`Task.Run()`、`Task.Factory.SatrtNew()`，除了这三种方式之外，还有一种不常见的方式，通过TaskCompletionSource<TResult>类型来创建任务。

当需要创建表示一个通知（notification）的基于事件的任务时，例如大部分I/O型任务，此时可以使用`TaskCompletionSource<TResult>` 类型来创建Task。

`TaskCompletionSource<TResulr>` 类可以对任务的生命周期做控制。

首先要通过 `.Task` 属性，获得一个 `Task` 或 `Task<TResult>` 。

```csharp
TaskCompletionSource<int> task = new TaskCompletionSource<int>();
Task<int> myTask = task.Task;    //  Task myTask = task.Task;
```

然后通过 `task.xxx()` 方法来控制 `myTask` 的生命周期，但是呢，myTask 本身是没有任务内容的。

使用示例如下：

```csharp
static void Main()
{
    TaskCompletionSource<int> task = new TaskCompletionSource<int>();
    Task<int> myTask = task.Task;       // task 控制 myTask

    // 新开一个任务做实验
    Task mainTask = new Task(() =>
    {
        Console.WriteLine("我可以控制 myTask 任务");
        Console.WriteLine("按下任意键，我让 myTask 任务立即完成");
        Console.ReadKey();
        task.SetResult(666);
    });
    mainTask.Start();

    Console.WriteLine("开始等待 myTask 返回结果");
    Console.WriteLine(myTask.Result);
    Console.WriteLine("结束");
    Console.ReadKey();
}
```

TaskCompletionSource 只能设置一次结果。

其他成员有：

- TrySetResult



### 创建Task的不同方式对比

todo：图



### 三种创建方式的综合示例

首先定义如下两个方法，用来记录任务和线程信息：

```c#
private static object s_logLock = new object();
public static void Log(string title)
{
    //使用lock可以让其他方法并行调用Log()，避免lock内的代码被多个线程或任务交叉调用
    lock (s_logLock)
    {
        Console.WriteLine(title);
        Console.WriteLine($"Task ID:{Task.CurrentId?.ToString() ?? "没有Task存在"}，Thread ID：{ Thread.CurrentThread.ManagedThreadId}");
        //如果不是.NET Core 1.0运行库就执行该语句
        #if (!DNXCORE)
            Console.WriteLine("是否是线程池线程：" + Thread.CurrentThread.IsThreadPoolThread);
        #endif
        Console.WriteLine("是否是后台线程：" + Thread.CurrentThread.IsBackground);
        Console.WriteLine();
    }
}
//使用Task需要传入Action<object>委托，所以此处定义的方法的参数为Object类型
public static void TaskMethod(object obj)
{
    Log(obj?.ToString());
}
```

使用上述提到的几种方式创建Task：

```c#
public static void TasksUsingThreadPool()
{
    Task t1 = new TaskFactory().StartNew(TaskMethod, "使用TaskFactory实例化形式创建任务");
    Task t2 = Task.Factory.StartNew(TaskMethod, "使用Task的Factory属性形式创建任务");
    Task t3 = new Task(TaskMethod, "使用Task构造函数并调用实例的Start()形式创建任务");
    t3.Start();
    Task t4 = Task.Run(() => { TaskMethod("使用Task.Run()形式创建任务"); });
}
//调用执行
TasksUsingThreadPool();
Console.WriteLine("-----程序执行完毕-----");
Console.Read();
```

调用上述方法代码如下：

```
-----程序执行完毕-----
使用Task的Factory属性形式创建任务
Task ID：1，Thread ID：3
是否是线程池线程：True
是否是后台线程：True

使用Task构造函数并调用实例的Start()形式创建任务
Task ID：2，Thread ID：4
是否是线程池线程：True
是否是后台线程：True

使用TaskFactory实例化形式创建任务
Task ID：3，Thread ID：6
是否是线程池线程：True
是否是后台线程：True

使用Task.Run()形式创建任务
Task ID：4，Thread ID：5
是否是线程池线程：True
是否是后台线程：True
```

上述通过结果可以看到，在输出了“程序执行完毕”之后，才执行创建的任务，并且使用了不同的线程。

### Task 使用非线程池中的线程

注意：==Task大多数情况下使用的是线程池中的线程，但并不是说Task一定要使用线程池中的线程，它还可以使用其他的线程。并且任务也可以同步运行，以相同的线程作为主调线程。==

如下所示：

```c#
public static void RunSynchronousTask()
{
    TaskMethod("主线程运行");
    var t1 = new Task(TaskMethod, "同步调用");
    //同步运行Task
    t1.RunSynchronously();
}
```

这里调用了`Task`的`RunSynchronously()`方法，输出结果如下：

```
主线程运行
Task ID：没有Task存在，Thread ID：1
是否是线程池线程：False
是否是后台线程：False

同步调用
Task ID：1，Thread ID：1
是否是线程池线程：False
是否是后台线程：False

-----程序执行完毕-----
```

在代码中，`TaskMethod()`方法首先在主线程上直接调用，然后在新创建的`Task`上调用，通过输出结果可以看出，主线程没有任务ID，也不是线程池中的线程。当调用`RunSynchronously()`方法后，会使用相同的线程作为主调线程，如果以前没有创建任务，就会创建一个新任务。

#### 使用单独线程的任务

如果任务的代码将长时间运行，就应该使用`TaskCreationOptions.LongRunning`告诉任务调度器创建一个新线程，而不是使用线程池中的线程。此时，线程可以不由线程池管理。当线程来自线程池时，任务调度器可以决定等待已经运行的任务完成，然后使用这个线程，而不是在线程池中创建一个新线程。

```c#
public static void LongRunningTask()
{
    var t1 = new Task(TaskMethod, "long runing", TaskCreationOptions.LongRunning);
    t1.Start();
}
```

执行结果如下：

```
-----程序执行完毕-----
long runing
Task ID：1，Thread ID：3
是否是线程池线程：False
是否是后台线程：True
```

==使用`TaskCreationOptions.LongRunning`选项时，不会使用线程池中的线程，而是会创建一个新线程。==



## Task 状态

可以通过下述属性获取Task相关的状态信息：

| 属性                    | 说明                                               |
| ----------------------- | -------------------------------------------------- |
| IsCanceled              | 获取此 Task 实例是否由于被取消的原因而已完成执行。 |
| IsCompleted             | 获取一个值，它表示是否已完成任务。                 |
| IsCompletedSuccessfully | 了解任务是否运行到完成。                           |
| IsFaulted               | 获取 Task是否由于未经处理异常的原因而完成。        |
| Status                  | 获取此任务的 TaskStatus。                          |

要检测一个任务是否出错(指任务因未经处理的异常而导致工作终止)，要使用 `IsCanceled` 和 `IsFaulted` 两个属性，只要任务抛出异常，`IsFaulted` 为 true。但是取消任务本质是抛出 `OperationCancelExcetion` 异常，不代表任务出错。

即使任务抛出了未经处理的异常，也算是完成了任务，因此 `IsCompleted` 属性，会为 true。

`Task.Status` 属性可以获取任务的状态。其属性类型是一个 TaskStatus 枚举，其定义如下：

| 枚举                         | 值   | 说明                                                         |
| ---------------------------- | ---- | ------------------------------------------------------------ |
| Canceled                     | 6    | 已经通过 CancellationToken 取消任务。                        |
| Created                      | 0    | 该任务已初始化，但尚未被计划。                               |
| Faulted                      | 7    | 由于未处理异常的原因而完成的任务。                           |
| RanToCompletion              | 5    | 已成功完成执行的任务。                                       |
| Running                      | 3    | 该任务正在运行，但尚未完成。                                 |
| WaitingForActivation         | 1    | 该任务正在等待 .NET Framework 基础结构在内部将其激活并进行计划。 |
| WaitingForChildrenToComplete | 4    | 该任务已完成执行，正在隐式等待附加的子任务完成。             |
| WaitingToRun                 | 2    | 该任务已被计划执行，但尚未开始执行。                         |

在使用并行任务时，`Task.Status` 的值，有一定规律：

- 如果有其中一个任务出现未经处理的异常，那么返回`TaskStatus.Faulted`；
- 如果所有任务都出现未经处理的异常，会返回 `TaskStatus. RanToCompletion`；
- 如果其中一个任务被取消(即使出现未经处理的异常)，会返回 `TaskStaus.Canceled`；



## Task 常用方法

### Task.GetAwaiter

Task 有个 `GetAwaiter()` 方法，会返回`TaskAwaiter` 或`TaskAwaiter<TResult>`。

`TaskAwaiter` 表示等待异步任务完成的对象并为结果提供参数。

`TaskAwaiter` 类型的属性和方法如下：

属性：

| 属性        | 说明                                     |
| ----------- | ---------------------------------------- |
| IsCompleted | 获取一个值，该值指示异步任务是否已完成。 |

方法：

| 方法                      | 说明                                                        |
| ------------------------- | ----------------------------------------------------------- |
| GetResult()               | 结束异步任务完成的等待。                                    |
| OnCompleted(Action)       | 将操作设置为当 TaskAwaiter 对象停止等待异步任务完成时执行。 |
| UnsafeOnCompleted(Action) | 计划与此 awaiter 相关异步任务的延续操作。                   |

```c#
static void Main()
{
    Task<int> task = new Task<int>(()=>
    {
        Console.WriteLine("我是前驱任务");
        Thread.Sleep(TimeSpan.FromSeconds(1));
        return 666;
    });

    TaskAwaiter<int> awaiter = task.GetAwaiter();

    awaiter.OnCompleted(()=>
    {
        Console.WriteLine("前驱任务完成时，我就会继续执行");
    });
    task.Start();

    Console.ReadKey();
}
```

==注意：在同步方法中调用异步方法，都推荐这种方式获取异步任务的结果，而不是直接使用异步任务的Result属性。==

### Task.WhenAll

`Task.WhenAll()` ：等待提供的所有 Task 对象完成执行过程。

```c#
static void Main()
{
    List<Task<int>> tasks = new List<Task<int>>();

    for (int i = 0; i < 5; i++)
        tasks.Add(Task.Run<int>(() =>
        {
            Console.WriteLine($"任务开始执行");
            return new Random().Next(0,10);
        }));

    Task<int[]> taskOne = Task.WhenAll(tasks);

    foreach (var item in taskOne.Result)
        Console.WriteLine(item);

    Console.ReadKey();
}
```

注意，当往一个Task集合中放入Task时，不能使用Task的构造函数来创建Task对象，而必须使用Task.Run或者StartNew()方法返回的Task对象才能放到集合中。下述代码虽然不报错，但是存在问题：

```c#
tasks.Add(new Task(() =>
{
    Console.WriteLine($"任务开始执行");
}));
```

这样写出的代码，无法使用Task.WhenAll启动。

### Task.WhenAny

`Task.WhenAny()` 和 `Task.WhenAll()` 使用上差不多，`Task.WhenAll()` 当所有任务都完成时，才算完成，而 `Task.WhenAny()` 只要其中一个任务完成，都算完成。

```c#
static void Main()
{
    List<Task> tasks = new List<Task>();

    for (int i = 0; i < 5; i++)
        tasks.Add(Task.Run(() =>
        {
            Thread.Sleep(TimeSpan.FromSeconds(new Random().Next(0, 5)));
            Console.WriteLine("     正在执行任务");
        }));
    Task taskOne = Task.WhenAny(tasks);
    taskOne.Wait(); // 任意一个任务完成，就可以解除等待

    Console.WriteLine("有任务已经完成了");

    Console.ReadKey();
}
```

当然，`Task.WhenAny()` 也有泛型方法，可以返回结果。

注意：在使用WhenAny()时，一定要借助取消来处理被丢弃的任务。WhenAny只会返回最先完成的任务，而其他的任务仍会继续执行，只是被丢弃了而已，如果不进行取消，将会白白占用系统的资源。

### Task.FromResult

从方法中返回任务。

返回任务和结果的方法声明为返回`Task<T>`。如果需要实现一个用同步代码定义的接口，就不需要为结果的值创建一个任务，可以使用`Task`类的`FromResult()`方法创建一个结果与完成的任务。该任务用状态`RanToCompletion`表示。

```c#
public Task<IEnumerable<string>> TaskMethodAsync()
{
    return Task.FromResult<IEnumerable<string>>(
        new List<string> { "one", "two" });
}
```

### Task.Yield

`Yield()`：如果将释放CPU，从而允许其他任务运行，就可以调用`Task.Yield()`方法。该方法释放CPU，让其他任务运行。如果没有其他任务等待运行，调用`Task.Yield()`的任务就立即继续执行。否则，需要等到再次调度CPU，以调用任务。 

### Task.Delay 和 Task.Wait

我们先定义一个简单的方法，在该方法中，等待3秒之后返回一个字符串：

```c#
public static string Greeting(string name)
{
    //等待3秒
    Task.Delay(3000).Wait(); //Wait方法用来等待之前的任务完成，不推荐使用
    return "Hello," + name;
}
```

上述方法中使用了[`Wait()`](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.wait?view=netframework-4.7.2)方法，该方法是一个同步方法，它使调用线程等到当前任务完成。如果当前任务尚未开始执行，则`Wait()`方法尝试从调度程序中删除该任务，并在当前线程上内联执行该任务。如果无法执行此操作，或者当前任务已经开始执行，则会阻止调用线程，直到任务完成。 

### ConfigureAwait(bool)

`.ConfigureAwait(bool)` 如果要尝试将延续任务封送回原始上下文，则为 `true`；否则为 `false`。

其使用方法如下：

```csharp
static void Main()
{
    Task<int> task = new Task<int>(()=>
    {
        Console.WriteLine("我是前驱任务");
        Thread.Sleep(TimeSpan.FromSeconds(1));
        return 666;
    });

    ConfiguredTaskAwaitable<int>.ConfiguredTaskAwaiter awaiter = task.ConfigureAwait(false).GetAwaiter();

    awaiter.OnCompleted(()=>
    {
        Console.WriteLine("前驱任务完成时，我就会继续执行");
    });
    task.Start();

    Console.ReadKey();
}
```

`ConfiguredTaskAwaitable<int>.ConfiguredTaskAwaiter` 拥有跟 `TaskAwaiter` 一样的属性和方法。

注意：在WPF或Winform程序中，当在主线程中调用async方法时，需要谨慎使用Task.Result获取该异步方法的结果。这是因为使用Result属性会阻塞主线程（UI线程），直到异步方法处理完成，而异步方法中含有await关键字，如果没有在await语句后面显式调用ConfigureAwait(false)，将会造成死锁。这是因为当异步方法中的await语句执行完后，将会切换到主线程中去，此时会和外部正在等待的UI线程形成死锁。**因此一定要避免使用Result来获取异步方法的结果，而是应该使用await语句**。

![image-20250625161147313](./assets/image-20250625161147313.png)



#### 同步上下文

有时候，为了执行某些动作，有些应用程序会绑定到指定的线程上。例如，在winform或WPF应用程序中，只有UI线程才能访问UI元素，这将会是一个问题。在未出现`async`和`await`之前，需要借助委托来解决这类问题，代码相对比较繁琐。

> 而使用`async`和`await`关键字，当`await`完成之后，不需要进行任何特别处理，就能访问UI线程。默认情况下，生成的代码就会把线程转换到拥有同步上下文的线程中。WPF设置了`DispatcherSynchronizationContex`t属性，winfrom设置了`WindowsFormsSynchronizationContext`属性。如果调用异步方法的线程分配了同步上下文，`await`完成之后将继续执行。默认情况下，使用了同步上下文。如果不使用相同的同步上下文，则必须调用Task方法`ConfigureAwait(continueOnCapturedContext:false)`。例如， 一个WPF应用程序，其`await`后面的代码没有用到任何的UI元素。在这种情况下，避免切换到同步上下文会执行的更快。



#### ContinueWith() 和 ConfigureAwait(false) 的区别

- ContinueWith()可以延续多个任务和延续任务的任务(多层)，而ConfigureAwait(false) 只能延续一层任务(一层可以有多个任务)。
- `.ContinueWith()` 延续的任务，当前驱任务完成后，延续任务会继续在此线程上继续执行。这种方式是同步的，前者和后者连续在一个线程上运行。而`ConfigureAwait(false)` 方法可以实现异步，前驱方法完成后，可以不理会后续任务，而且后续任务可以在任意一个线程上运行。这个特性在 UI 界面程序上特别有用。



### 其他不推荐的方法

- Task.Wait
- Task.WaitAll
- Task.WaitAny

`Task.WaitAll()` 会让当前线程等待所有任务执行完毕。并且 `Task.WaitAll()` 是没有泛型的，也么没有返回结果。

Task.WhenAll 不会阻塞调用线程，而Wait、WaitAll、WaitAny 会阻塞调用线程。



## async 和 await

`async`和`await`关键字只是编译器功能，实质是编译器会用`Task`类创建代码。

### async

微软文档：使用 `async` 修饰符可将方法、lambda 表达式或匿名方法指定为异步。

使用 async 修饰的方法，称为异步方法。

- async关键字加在方法声明上
- 主要目的是使方法内的await关键字生效
- 如果async方法有返回值，应返回Task<T>；如果没有返回值，应返回Task。（这些Task类型相当于future，用来在异步方法结束时通知主程序）
- 不要用void作为async方法的返回类型（只有在编写事件处理程序时，才可以返回void），一个普通的async方法，如果没有返回值，要返回Task，而不是void。
- 一个async方法是由多个同步执行的程序块组成的，每个同步程序块之间由await语句分隔。

例如：

为了命名规范，使用 async 修饰的方法，需要在方法名称后面加上 `Async` 。

```csharp
public async Task<int> TestAsync()  
{  
    // . . . .  
}
```

Lambda ：

```csharp
        static void Main()
        {
            Thread thread = new Thread(async () =>
            {
                await Task.Delay(0);
            });
        }
        public static async Task<int> TestAsync() => 666;
```

### await

微软文档：`await` 运算符暂停对其所属的 `async` 方法的求值，直到其操作数表示的异步操作完成。

异步操作完成后，`await` 运算符将返回操作的结果（如果有），如果你使用了 await ，那么**这段代码相当于变成同步了**。

==C#编译器会把`await`关键字后的所有代码放进`ContinueWith()`方法的代码块中来转换`await`关键字。==

`Task`类的`ContinueWith()`方法定义了任务完成后就调用的代码。指派给`ContinueWith()`方法的委托接收将已完成的任务作为参数传入，使用`Result`属性可以访问任务返回的结果。

- 在async方法内部，await关键字对它的参数（await关键字后面的内容）执行一个异步等待。
- await会检查其后的操作是否已经完成，如果完成了，就继续以同步的方式往下运行。否则，它会暂停async方法，并返回，留下一个未完成的Task。一段时间后，操作完成，async方法就恢复运行。
- 当使用await时，为了让每个同步程序块能够正确的在原始的上下文中恢复运行，建议在await中使用configureAwait方法，将参数continueOnCapturedContext设为false，这样每个恢复运行的同步程序块，将会忽略上下文，将会在线程池中的线程上继续运行。例如： await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);
- await才是线程切换的起点，而不是async。



### async 和 await 使用说明

- `await`关键字用来修饰的是返回`Task[<T>]`的方法，而不是一个返回普通类型的方法，并不是方法名带有`async`就一定要使用await关键字修饰，需要根据该方法返回的类型进行确定。

- 在方法的内部使用了`await`关键字的方法，必须使用`async`关键字进行修饰。

- 如果方法内部没有await关键字修饰的表达式，哪怕函数被async修饰也只能算作同步方法，执行的时候也是同步执行的。例如：

  ```csharp
  public async Task<int> GetAge()
  {
  	return 10;
  }
  等同于：
  public async Task<int> GetAge()
  {
  	return await Task.FromResult(10);
  }
  ```

- 使用了`async`关键字修饰的方法，在被主线程调用时，该主线程并不会受方法内部的`await`关键字的影响，不会被阻塞，依然会运行。而方法内部使用`await`修饰的代码，在未完成前，其他代码不会被执行。

- 如果方法使用了async关键字修饰，无论该方法返回的是void还是Task或者Task<T>，该方法被调用时，如果主调线程没有使用await关键字，那么该方法都是以异步的方式被主线程执行的。也就是异步调用跟方法的返回值无关，而与async关键字修饰有关。一般来说，如果返回的是Task，都会使用async修饰，如果不想在方法调用时，被VS提示建议使用await关键字，可以将方法的返回值由Task改为void。

- 一旦在代码中使用了async，最好一直使用。

- 调用异步方法时，应该（在调用结束时）用await等待它返回的task对象。

- 不要在异步方法中使用Task.Wait或Task<T>.Result方法，因为它们会导致死锁。死锁的解决办法：1、使用ConfigureAwait(false)；2、使用await语句调用taskAsync异步方法来替换task.Wait()。





## TaskScheduler

表示一个处理将任务排队到线程中的低级工作的对象。



### 自定义任务调度机制（TaskScheduler）

默认情况下，创建多个Task，他们的ThreadId可能是不同的，可以自定义TaskScheduler，实现同一个线程执行不同Task。

```csharp
internal class Program {

    private static void Main(string[] args) {
        var scheduler = new CustomTaskScheduler();
        for (int i = 0; i < 100; i++) {
            var task = Task.Factory.StartNew(() => {
                Console.WriteLine($"线程Id：{Environment.CurrentManagedThreadId}");
            }, CancellationToken.None, TaskCreationOptions.None, scheduler);
        }
        Console.ReadLine();
    }
}
// 自定义一个TaskScheduler，重写相关方法
public class CustomTaskScheduler : TaskScheduler {

    //定义一个Thread执行所有的Task
    private Thread th = null;

    private BlockingCollection<Task> collection = new BlockingCollection<Task>();

    public CustomTaskScheduler() {
        th = new Thread(() => {
            foreach (var task in collection.GetConsumingEnumerable()) {
                TryExecuteTask(task);
            }
        });
        th.Start();
    }

    protected override IEnumerable<Task> GetScheduledTasks() {
        return collection.ToArray();
    }

    protected override void QueueTask(Task task) {
        collection.Add(task);
    }

    protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued) {
        throw new NotImplementedException();
    }
}
```







## AsyncBarrier

位于Microsoft.VisualStudio.Threading 包中，但不推荐使用。更推荐使用Nito.AsyncEx包中提供的方法来代替。

适用场景：允许启动多个任务，任务的先后顺序无所谓，但要求必须**同时**完成，此时可以通过AsyncBarrier来实现。











## 转换异步模式（将APM转换为TAP ）【补充了解，不常用】

把使用旧的异步模式（APM）的方法转换为基于任务的异步模式的方法（TAP）

并非.NET Framework的所有类都引入了新的异步方法，有些类只提供了BeginXXX方法和EndXXX方法的异步模式，没有提供基于任务的异步模式。我们可以把这些旧的异步模式转换为新的基于任务的异步模式。

为了模拟出BeginXXX和EndXXX这种形式的方法，对之前的同步方法`Greeting()`进行扩展：

```c#
public static string Greeting(string name)
{
    //等待3秒
    Task.Delay(3000).Wait(); //Wait方法用来等待之前的任务完成
    return "Hello," + name;
}
//定义一个委托
private static  Func<string, string> greetingInvoker = Greeting;

//模拟异步模式
private static IAsyncResult BeginGreeting(
    string name,AsyncCallback callback, object state)
{
    return greetingInvoker.BeginInvoke(name, callback, state);
}
//该方法返回来自于Greeting的结果
private static string EndGreeting(IAsyncResult ar)
{
    return greetingInvoker.EndInvoke(ar);
}
//使用新的基于任务的异步模式进行调用
public static async void ConvertingAsyncPattern()
{
    string s = await Task<string>.Factory.FromAsync<string>(
        BeginGreeting, EndGreeting, "测试", null);
    Console.WriteLine(s);
}
```

> 上述实例中，使用`TaskFactory`类的`FromAsync()`方法，把使用旧的异步模式的方法转换为基于任务的异步模式的方法（TAP）。其中，`Task`类型的第一个泛型参数`Task<string>`定义了调用方法的**返回值类型**。`FromAsync()`方法的泛型参数定义了方法的**输入类型**。`FromAsync()`方法的前两个参数是委托类型，传入`BeginGreeting`和`EndGreeting`方法的声明。紧跟这两个参数后面的是输入参数和对象状态参数。因对象状态没有用到，所以分配`null`值。因为`FromAsync()`方法返回`Task`类型，可以使用`await`修饰。









---

References：

- 《C#高级编程（第10版）》
- [C#概念——异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/async)
- [.NET并行处理、并发和异步——异步概述](https://docs.microsoft.com/zh-cn/dotnet/standard/async)
- [C#指南——C#使用Async和await的异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/)
- 《C#7,0 核心技术指南》

- [基于任务的异步模式（TAP）：简介和概述 - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)

- [C#中利用AsyncBarrier实现多个异步任务的同时完成_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Gx4y1479f?spm_id_from=333.788.player.switch&vd_source=e3d65fed6c5d2bee448a9a010e7d9a81)

Last updated：2025-08-31
