# C# 线程同步

线程安全指的是多个线程访问共享资源时，对共享资源的访问不会导致数据不一致或不可预期的结果。

解决线程安全的常见方式：

- 同步机制：用于协调和控制多个线程之间执行顺序和互斥访问共享资源。确保线程按照特定的顺序执行，避免竞态条件和数据不一致的问题。
- 原子操作：在执行过程中不会被中断的操作。不可分割，要么完全执行，要么完全不执行，没有中间状态。在多线程环境下，原子操作能够保证数据的一致性和可靠性，避免出现竞态条件和数据竞争的问题。C#中用于进行原子操作的主要是Interlocked类型。

如果需要共享数据，就必须使用同步技术，确保一次只有一个线程访问和改变共享状态。如果不注意同步，就会出现争用条件和死锁。

同步（synchronization）是指==协调并发操作，得到可以预测的结果的行为==，主要用于多个线程访问同一个数据时的操作。

==如果有 N 个线程都会执行某个操作，当一个线程正在执行这个操作时，其它线程都必须依次等待，这就是线程同步。==

最简单的也是最实用的同步做法是使用任务延续（continuation）和任务组合器。延续和任务组合器将并发程序构造为异步操作，减少了对锁和信号发送的依赖。具体参考任务章节。

线程同步结构分为四类：

- 每次只允许==一个==线程执行特定的活动或一段代码：**排它锁**
  - lock
  - Mutex
  - SpinLock
- 用于控制==多个==线程执行特定的活动或代码，实现有限的并发性的：**非排它锁**
  - Semaphore（Slim）
  - ReaderWriterLock（Slim）
- 允许线程在接到一个或者多个其他线程的通知之前保持阻塞状态：**信号发送结构**
  -  ManualResetEvent（Slim）
  - AutoResetEvent
  - CountdownEvent
  - Barrier

- 除此之外，一些结构在不使用锁的前提下也可以巧妙地处理特定的共享状态的同步操作，称为**非阻塞同步结构（nonblocking synchronization construct）**。包括：
  - volatile关键字和Interlocked类
  - Thread.MemoryBarrier
  - Thread.VolatileRead
  - Thread.VolatileWrite



## 多线程竞争下的原子操作

### 竞争条件

当两个或两个以上的线程访问共享数据，并且尝试同时改变它时，就会发生争用的情况。它们所依赖的那部分共享数据，叫做竞争条件。

数据争用是竞争条件中的一种，出现竞争条件可能会导致内存(数据)损坏或者出现不确定性的行为。

### 线程同步

如果有 N 个线程都会执行某个操作，当一个线程正在执行这个操作时，其它线程都必须依次等待，这就是线程同步。

多线程环境下出现竞争条件，通常是没有执行正确的同步而导致的。

### CPU时间片和上下文切换

**时间片（timeslice）**是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。

> 首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间 片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。

**上下文切换（Context Switch）**，也称做进程切换或任务切换，是指 CPU 从一个进程或线程切换到另一个进程或线程。

> 在接受到中断（Interrupt）的时候，CPU 必须要进行上下文交换。进行上下文切换时，会带来性能损失。

### 阻塞

阻塞状态指==线程处于等待状态==。当线程处于阻塞状态时，会尽可能少占用 CPU 时间。

当线程从运行状态(Runing)变为阻塞状态时(WaitSleepJoin)，操作系统就会将此线程占用的 CPU 时间片分配给别的线程。当线程恢复运行状态时(Runing)，操作系统会重新分配 CPU 时间片。

分配 CPU 时间片时，会出现上下文切换。

### 内核模式和用户模式

只有操作系统才能切换线程、挂起线程，因此阻塞线程是由操作系统处理的，这种方式被称为内核模式(kernel-mode)。

`Sleep()`、`Join()` 等，都是使用内核模式来阻塞线程，实现线程同步(等待)。

==内核模式实现线程等待时，出现上下文切换。这适合等待时间比较长的操作，这样会减少大量的 CPU 时间损耗。==

如果线程只需要等待非常微小的时间，阻塞线程带来的上下文切换代价会比较大，这时我们可以使用**自旋**，来实现线程同步，这一方法称为用户模式(user-mode)。

### 死锁

锁定并不是越多越好，过多的锁定会造成死锁，在死锁中，至少有两个线程被挂起，并等待对象解除锁定。由于两个线程都在等待对方，就出现了死锁，线程将无限等待下去。





----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [2. 线程同步 · C# 多线程与异步](https://threads.whuanle.cn/2.thread_sync/)

Last updated：2025-08-31





