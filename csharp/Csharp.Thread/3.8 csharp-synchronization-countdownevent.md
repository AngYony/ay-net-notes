# C#线程同步——CountdownEvent

CountdownEvent 可用于在一个线程中等待其他多个线程，通过信号计数的方式，当多个线程执行完毕之后，再执行后续操作。类似于Task.WaitAll方法的效果。

CountdownEvent 的构造函数定义如下：

```csharp
public CountdownEvent (int initialCount);
```

- initialCount：指定线程数目或者需要等待的线程“计数”。
- 

### CountdownEvent 的常用方法

- [Signal()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.countdownevent.signal?view=netframework-4.8#system-threading-countdownevent-signal)：向 CountdownEvent 注册信号，同时减小 CurrentCount 的值。
- [Signal(Int32)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.countdownevent.signal?view=netframework-4.8#system-threading-countdownevent-signal(system-int32))：向 CountdownEvent 注册多个信号，同时将 CurrentCount 的值减少指定数量。
- [AddCount()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.countdownevent.addcount?view=netframework-4.8#system-threading-countdownevent-addcount)：将 CountdownEvent 的当前计数加 1。
- [AddCount(Int32)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.countdownevent.addcount?view=netframework-4.8#system-threading-countdownevent-addcount(system-int32))：将 CountdownEvent 的当前计数增加指定值。
- [Reset()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.countdownevent.reset?view=netframework-4.8#system-threading-countdownevent-reset)：将 CurrentCount 重置为 InitialCount 的值。
- [Reset(Int32)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.countdownevent.reset?view=netframework-4.8#system-threading-countdownevent-reset(system-int32))：将 InitialCount 属性重新设置为指定值。
- [TryAddCount()](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.countdownevent.tryaddcount?view=netframework-4.8#system-threading-countdownevent-tryaddcount)：增加一个 CurrentCount 的尝试。
- [TryAddCount(Int32)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.countdownevent.tryaddcount?view=netframework-4.8#system-threading-countdownevent-tryaddcount(system-int32))：增加指定值的 CurrentCount 的尝试。

调用 Signal 会使计数递减，而调用 Wait 则会阻塞，直至计数减为零。调用AddCount方法可以重新增加CountdownEvent的计数，但是如果它的计数已经降为0，则调用该方法会抛出异常。为了避免抛出异常，还可以使用TryAddCount，若计数值为0，则该方法返回false。

注意：无法通过调用AddCount来取消CountdownEvent的信号。而调用Reset方法可以取消计数事件的信号：它不但取消信号，而且会将计数值重置为原始设定值。



### CountdownEvent 实战

- 实例化CountdownEvent对象，指定要等待的线程的数量。
- 在外部线程中调用Wait()方法，等待其他线程的执行。
- 在其他线程中调用Signal()方法注册信号，并将计数减一。
- 当计数清零之后，外部等待的线程恢复执行。

示例：

```c#
//等待三个线程
static CountdownEvent _countdown = new CountdownEvent(3);
static void Main(string[] args)
{
    new Thread(SaySomething).Start("第一个线程");
    new Thread(SaySomething).Start("第二个线程");
    new Thread(SaySomething).Start("第三个线程");
    //等待CountdownEvent的计数清零
    _countdown.Wait();   // Blocks until Signal has been called 3 times
    Console.WriteLine("所有的线程都结束运行!");
    Console.ReadLine();
}
static void SaySomething(object thing)
{
    Console.WriteLine(thing);
    Console.ReadLine();
    Console.WriteLine(thing + "按下回车键结束运行");
    // 向CountDownEvent注册信号，将CountdownEvent计数减一
    _countdown.Signal();
}
```

注意：优先使用PLINQ和Parallel类，再使用CountdownEvent。



### 信号发送结构的性能

- 在无阻塞的情况下，等待或激活一个AutoResetEvent 或者 ManualResetEvent对象需要消耗一微秒的时间。
- 在短暂的等待中，ManualResetEventSlim 和 CountdownEvent的速度要快50倍，因为他们不依赖操作系统，并且谨慎的使用了自旋结构。
- 在大多数情况下，信号发送类本身的开销并不会形成瓶颈，因此很少需要特意进行考虑。





