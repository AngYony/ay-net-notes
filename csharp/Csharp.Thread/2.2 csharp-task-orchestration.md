# C# 任务的编排



## 父子 Task

父任务和子任务是由TaskCreationOptions来指定的，与父子任务相关的TaskCreationOptions枚举值如下：

| 枚举             | 值   | 说明                                                         |
| ---------------- | ---- | ------------------------------------------------------------ |
| AttachedToParent | 4    | 指定将任务附加到任务层次结构中的某个父级。                   |
| DenyChildAttach  | 8    | 指定任何尝试作为附加的子任务执行的子任务都无法附加到父任务，会改成作为分离的子任务执行。 |

注意，子任务使用了 TaskCreationOptions.AttachedToParent ，并不是指父任务要等待子任务完成后，父任务才能继续完往下执行；而是指父任务如果先执行完毕，那么必须等待子任务完成后，父任务才算完成。

而 `TaskCreationOptions.DenyChildAttach` 则不允许其它任务附加到外层任务中。

先看看非父子任务下，外层任务不会等待内嵌的任务完成，直接完成或返回结果：

```C#
static void Main()
{
    //两个任务没有从属关系，是独立的
    Task<int> task = new Task<int>(() =>
    {
        // 非子任务
        Task task1 = new Task(() =>
        {
            Thread.Sleep(TimeSpan.FromSeconds(1));
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine("     内层任务1");
                Thread.Sleep(TimeSpan.FromSeconds(0.5));
            }
        });
        task1.Start();
        return 666;
    });
    task.Start();
    Console.WriteLine($"任务运算结果是：{task.Result}");
    Console.WriteLine("\n-------------------\n");
    Console.ReadKey();
}
```

使用`TaskCreationOptions.AttachedToParent`实现父子任务，父任务等待子任务完成后，才能算完成任务，然后返回结果：

```csharp
 static void Main()
{
    // 父子任务
    Task<int> task = new Task<int>(() =>
    {
        // 子任务
        Task task1 = new Task(() =>
        {
            Thread.Sleep(TimeSpan.FromSeconds(1));
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine("     内层任务1");
                Thread.Sleep(TimeSpan.FromSeconds(0.5));
            }
        }, TaskCreationOptions.AttachedToParent);
        task1.Start();

        Console.WriteLine("最外层任务");
        return 666;
    });

    task.Start();
    Console.WriteLine($"任务运算结果是：{task.Result}");
    Console.WriteLine("\n-------------------\n");

    Console.ReadKey();
}
```

而 `TaskCreationOptions.DenyChildAttach` 则不允许其它任务附加到外层任务中。

TaskCreationOptions.DenyChildAttach 的使用示例：

```c#
static void Main()
{
    // 不允许出现父子任务
    Task task = new Task(() =>
    {
        Task task1 = new Task(() =>
        {
            Thread.Sleep(TimeSpan.FromSeconds(1));
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine("  内层任务1");
                Thread.Sleep(TimeSpan.FromSeconds(0.5));
            }
        }, TaskCreationOptions.AttachedToParent);
        task1.Start();

        Console.WriteLine("最外层任务");
        Thread.Sleep(TimeSpan.FromSeconds(1));
    }, TaskCreationOptions.DenyChildAttach); // 不收儿子

    task.Start();
    task.Wait();

    Console.ReadKey();
}
```

如果父任务是通过调用 Task.Run 方法而创建的，则可以隐式阻止子任务附加到其中。



## 延续 Task

### ContinueWith()

通过任务，可以指定在任务完成后，应开始运行另一个特定任务。连续任务通过在任务上调用`ContinueWith()`方法来定义，该方法需要传递一个Task类型参数的委托`Action<Task>`，该委托的`Task`类型代表着上一个任务，连续任务也可以使用`TaskFactory`类来定义。

`Task.ContinueWith()` 方法创建一个在 任务(Task)实例 完成时异步执行的延续任务。

`ContinueWith()` 重载方法很多，它们的参数都含有下面几种参数之一或多个。

- continuationAction：参数类型是Action 或 Func，表示一个要执行的任务。

- state：参数类型是Object，表示给延续任务传递的参数。

- cancellationToken：参数类型是CancellationToken，表示取消标记。

- continuationOptions：参数类型是TaskContinuationOptions，表示控制延续任务的创建和特性。

- scheduler：参数类型是TaskScheduler，表示要与延续任务关联并用于其执行过程的 TaskScheduler。

一个任务(Task) 是可以设置多个延续任务的，这些任务是并行的。

无论前一个任务如何结束，连续任务总是在它前一个任务结束时才启动。使用`TaskContinuationOptions`枚举中的值可以指定，连续任务只有在起始任务成功或失败结束时启动。该枚举常用的值有`OnlyOnFaulted`、`NotOnCanceled`、`OnlyOnCanceled`、`NotOnCanceled`和`OnlyOnRanToCompletion`等。

```c#
//任务如果出现异常，需要执行的任务
private static void DoOnError(Task obj)
{
    throw new NotImplementedException();
}
//指定只有在延续任务前面的任务引发了未处理异常的情况下才应安排延续任务。
Task t5 = t1.ContinueWith(DoOnError, TaskContinuationOptions.OnlyOnFaulted);
```

#### ContinueWith() 示例

示例一，依次顺序执行的任务：

```c#
Task task = new Task(() =>
{
    Console.WriteLine("     第一个任务");
    Thread.Sleep(TimeSpan.FromSeconds(2));
});

// 接下来第二个任务
task.ContinueWith(t =>
{
    Console.WriteLine($"     第二个任务}");
    Thread.Sleep(TimeSpan.FromSeconds(2));
});
task.Start();
```

示例二，一个任务设置多个延续任务，这些任务是并行的：

```c#
static void Main()
{
    Task task = new Task(() =>
    {
        Console.WriteLine("     第一个任务");
        Thread.Sleep(TimeSpan.FromSeconds(1));
    });

    // 任务1
    task.ContinueWith(t =>
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"    任务1");
            Thread.Sleep(TimeSpan.FromSeconds(1));
        }
    });

    // 任务2
    task.ContinueWith(t =>
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"     任务2");
            Thread.Sleep(TimeSpan.FromSeconds(1));
        }
    });

    // 任务1 和 任务2 属于同级并行任务
    task.Start();
}
```

示例三，具有嵌套关系的父子任务使用TaskContinuationOptions.AttachedToParent：

```c#
static void Main()
{
    // 父子任务
    Task<int> task = new Task<int>(() =>
    {
        // 子任务
        Task task1 = new Task(() =>
        {
            Thread.Sleep(TimeSpan.FromSeconds(1));
            Console.WriteLine("     内层任务1");
            Thread.Sleep(TimeSpan.FromSeconds(0.5));
        }, TaskCreationOptions.AttachedToParent);

        task1.ContinueWith(t =>
        {
            Thread.Sleep(TimeSpan.FromSeconds(1));
            Console.WriteLine("内层延续任务，也属于子任务");
            Thread.Sleep(TimeSpan.FromSeconds(0.5));
        }, TaskContinuationOptions.AttachedToParent);

        task1.Start();

        Console.WriteLine("最外层任务");
        return 666;
    });

    task.Start();
    Console.WriteLine($"任务运算结果是：{task.Result}");
    Console.WriteLine("\n-------------------\n");

    Console.ReadKey();
}
```

注意：`TaskContinuationOptions` 需要有嵌套关系的父子任务，才能生效。



## 编排任务示例

### 任务A、任务B、任务C依次顺序执行

```csharp
public static void SayA() {
    Console.WriteLine("A开始执行");
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}");
    Thread.Sleep(2000);
    Console.WriteLine("A执行完毕");
}

public static void SayB() {
    Console.WriteLine("B开始执行");
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}");
    Thread.Sleep(1000);
    Console.WriteLine("B执行完毕");
}

public static void SayC() {
    Console.WriteLine("C开始执行");
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}");
    Thread.Sleep(3000);
    Console.WriteLine("C执行完毕");
}

// 串行化Task
public static void ShunXu() {
    Console.WriteLine("串行执行任务");
    var task = Task.Factory.StartNew(() => {
        SayA();
    }).ContinueWith(t => {
        SayB();
    }).ContinueWith(t => {
        SayC();
    });

    task.Wait();
    Console.WriteLine("全部执行完成!");
    Console.Read();
}
```

### 任务A执行完后，任务B和任务C同时并行执行

```c#
static void Main()
{
    Task task = new Task(() =>
    {
        Console.WriteLine("     第一个任务");
        Thread.Sleep(TimeSpan.FromSeconds(1));
    });

    // 任务1
    task.ContinueWith(t =>
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"    任务1");
            Thread.Sleep(TimeSpan.FromSeconds(1));
        }
    });

    // 任务2
    task.ContinueWith(t =>
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"     任务2");
            Thread.Sleep(TimeSpan.FromSeconds(1));
        }
    });

    // 任务1 和 任务2 属于同级并行任务
    task.Start();
}
```

### 任务A和任务B并行执行完成后，执行任务C

核心在于调用WhenAll()和ContinueWith()方法。

```csharp
// 并行执行A和B，执行完成之后再执行C
public static void BingXing() {
    var tasks = new Task[2];
    tasks[0] = Task.Factory.StartNew(() => {
        SayA();
    });
    tasks[1] = Task.Factory.StartNew(() => {
        SayB();
    });
    Task.WhenAll(tasks).ContinueWith(t => {
        SayC();
    }).Wait();
    Console.WriteLine("全部执行完成!");
    Console.Read();
}
```

### 任务A里面包含子任务A1和A2，父任务A执行完成之后，再执行任务B

核心在于子任务指定TaskCreationOptions.AttachedToParent选项。

```csharp
public static void SayChildA() {
    Console.WriteLine("ChildA开始执行");
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}");
    Thread.Sleep(2000);
    Console.WriteLine("ChildA执行完毕");
}
public static void SayChildB() {
    Console.WriteLine("ChildB开始执行");
    Console.WriteLine($"当前任务的线程的ID：{Environment.CurrentManagedThreadId}");
    Thread.Sleep(3000);
    Console.WriteLine("ChildB执行完毕");
}

//一个父Task包含2个子Task，子任务不执行完，父级任务是不能结束的
public static void FuZiTask() {
    var parentTask = Task.Factory.StartNew(() => {
        // 子task1
        var child1Task = Task.Factory.StartNew(() => {
            SayChildA();
        }, TaskCreationOptions.AttachedToParent);

        var child2Task = Task.Factory.StartNew(() => {
            SayChildB();
        }, TaskCreationOptions.AttachedToParent);
    });
	// 父级任务执行完成之后，再执行任务B
    parentTask.ContinueWith(t => {
        SayB();
    }).Wait();

    Console.WriteLine("全部执行完成!");
    Console.Read();
}
```

### 任务A里面包含子任务A1和A2，子任务需要顺序执行

```c#
static void Main()
{
    // 父子任务
    Task<int> task = new Task<int>(() =>
    {
        // 子任务
        Task task1 = new Task(() =>
        {
            Thread.Sleep(TimeSpan.FromSeconds(1));
            Console.WriteLine("     内层任务1");
            Thread.Sleep(TimeSpan.FromSeconds(0.5));
        }, TaskCreationOptions.AttachedToParent);

        task1.ContinueWith(t =>
        {
            Thread.Sleep(TimeSpan.FromSeconds(1));
            Console.WriteLine("内层延续任务，也属于子任务");
            Thread.Sleep(TimeSpan.FromSeconds(0.5));
        }, TaskContinuationOptions.AttachedToParent);

        task1.Start();

        Console.WriteLine("最外层任务");
        return 666;
    });

    task.Start();
    Console.WriteLine($"任务运算结果是：{task.Result}");
    Console.WriteLine("\n-------------------\n");

    Console.ReadKey();
}
```

注意：`TaskContinuationOptions` 需要有嵌套关系的父子任务，才能生效。













---

References：

- 《C#高级编程（第10版）》
- [C#概念——异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/async)
- [.NET并行处理、并发和异步——异步概述](https://docs.microsoft.com/zh-cn/dotnet/standard/async)
- [C#指南——C#使用Async和await的异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/)
- 《C#7,0 核心技术指南》

- [基于任务的异步模式（TAP）：简介和概述 - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)

- [C#中利用AsyncBarrier实现多个异步任务的同时完成_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Gx4y1479f?spm_id_from=333.788.player.switch&vd_source=e3d65fed6c5d2bee448a9a010e7d9a81)

Last updated：2025-06-25
