# C# 线程同步——Monitor 锁和 lock 关键字

Monitor 锁和 lock 都属于排它锁。



## lock 关键字

lock 是 Monitor 实现的语法糖。生成的代码对比：

```c#
lock (x)
{
    // Your code...
}
```

```c#
object __lockObj = x;
bool __lockWasTaken = false;
try
{
    System.Threading.Monitor.Enter(__lockObj, ref __lockWasTaken);
    // Your code...
}
finally
{
    if (__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);
}
```

lock通常采用对一个引用类型（因为值类型只是锁定了一个副本，并没有任何意义）进行加锁，在该引用类型的对象的锁定未被解除时，其他线程无法访问该对象。而从保证了lock包裹的代码，在同一时刻只会有一个线程在执行。相当于封装成了一个原子操作，当一个线程持有锁时，其他线程将无法访问锁体内的代码。

在`lock`语句块结束时，对象的锁定被解除，另一个等待锁定的线程就可以获得该锁定块了。

使用`lock`语句，如果要锁定静态成员，可以把锁放在`object`类型或静态成员上。

例如，如果有两个线程同时访问同一个类的实例，就可以在该类中定义一个Object类型的对象，然后在其他成员方法中对该对象使用lock语句，从而保证了实例成员的线程安全。

lock 示例代码：

```csharp
class Program
{
    private static object obj = new object();
    private static int sum = 0;
    static void Main(string[] args)
    {
        Thread thread1 = new Thread(Sum1);
        thread1.Start();
        Thread thread2 = new Thread(Sum2);
        thread2.Start();
        while (true)
        {
            Console.WriteLine($"{DateTime.Now.ToString()}:" + sum);
            Thread.Sleep(TimeSpan.FromSeconds(1));
        }
    }

    public static void Sum1()
    {
        sum = 0;
        lock (obj)
        {
            for (int i = 0; i < 10; i++)
            {
                sum += i;
                Console.WriteLine("Sum1");
                Thread.Sleep(TimeSpan.FromSeconds(2));
            }
        }
    }

    public static void Sum2()
    {
        sum = 0;
        lock (obj)
        {
            for (int i = 0; i < 10; i++)
            {
                sum += 1;
                Console.WriteLine("Sum2");
                Thread.Sleep(TimeSpan.FromSeconds(2));
            }
        }
    }
}
```

也可以将类自己设置为锁， 这可以防止恶意代码对公共对象采用做锁。

例如：

```csharp
  public void Access()
    {
        lock(this) {}
     }
```

注意：

- 锁可以阻止其它线程执行锁块(lock(o){})中的代码，当锁定时，其它线程必须等待锁中的线程执行完成并释放锁。但是这可能会给程序带来性能影响。
- 锁不太适合I/O场景，例如文件I/O，繁杂的计算或者操作比较持久的过程，会给程序带来很大的性能损失。



## Monitor 类

与C#的`lock`语句相比，`Monitor`类的主要优点是：可以添加一个等待被锁定的超时值。这样其他线程就不会无限期地等待被锁定。可以使用`Monitor.TryEnter()`方法，并为该方法传递一个超时值，指定等待进入的最长时间。

```
bool _lockTaken = false;
Monitor.TryEnter(_obj, 500, ref _lockTaken);
if (_lockTaken)
{
    try
    {

    }
    finally
    {
        Monitor.Exit(_obj);
    }
}
else
{
    //didn't get the lock,do something else
}
```

> 上述中，如果`obj`被锁定，`TryEnter()`方法就把布尔型的引用参数设置为`true`，并同步的访问由对象`obj`锁定的状态。如果另个一线程锁定`obj`的时间超过了500毫秒，`TryEnter()`方法就把变量`lockTaken`设置为`false`，线程不在等待，而是用于执行其他操作。也许在以后，该线程会尝试再次获得锁定。

| 操作             | 说明                                                         |
| :--------------- | :----------------------------------------------------------- |
| Enter， TryEnter | 获取对象的锁。 此操作还标记关键节的开头。 其他任何线程都不能输入临界区，除非它使用不同的锁定对象执行临界区中的说明。 |
| Wait             | 释放对象的锁，以允许其他线程锁定并访问对象。 调用线程会等待另一个线程访问对象。 使用脉冲信号通知等待线程关于对象状态的更改。 |
| Pulse 、PulseAll | 将信号发送到一个或多个等待线程。 信号通知等待线程：锁定对象的状态已更改，锁的所有者已准备好释放该锁。 正在等待的线程置于对象的就绪队列中，因此它可能最终接收对象的锁。 线程锁定后，它可以检查对象的新状态，以查看是否已达到所需的状态。 |
| Exit             | 释放对象的锁。 此操作还标记受锁定对象保护的临界区的结尾。    |

示例一：

```csharp
private static object obj = new object();
private static bool acquiredLock = false;

public static void Test()
{
    try
    {
        Monitor.Enter(obj, ref acquiredLock);
    }
    catch { }
    finally
    {
        if (acquiredLock)
            Monitor.Exit(obj);
    }
}
```

`Monitor.Enter` 锁定 obj 这个对象，并且设置 acquiredLock 为 true，告诉别人 obj 已经被锁定。最后结束时，判断 acquiredLock ，释放锁，并设置 acquiredLock 为 false。

临界区：指被某些符号包围的范围。例如 `{}` 内。

Monitor 对象的 Enter 和 Exit 方法来标记临界区的开头和结尾。

`Enter()` 方法获取锁后，能够保证只有单个线程能够使用临界区中的代码。使用 Monitor 类，最好搭配 `try{...}catch{...}finally{...}` 来使用，因为如果获取到锁但是没有释放锁的话，会导致其它线程无限阻塞，即发生死锁。

一般来说，lock 关键字够用了。

下面示范了多个线程如何使用 Monitor 来实现锁：

```csharp
private static object obj = new object();
private static bool acquiredLock = false;
static void Main(string[] args)
{
    new Thread(Test1).Start();
    Thread.Sleep(1000);
    new Thread(Test2).Start();
}

public static void Test1()
{
    try
    {
        Monitor.Enter(obj, ref acquiredLock);
        for (int i = 0; i < 10; i++)
        {
            Console.WriteLine("Test1正在锁定资源");
            Thread.Sleep(1000);
        }
    }
    catch { }
    finally
    {
        if (acquiredLock)
            Monitor.Exit(obj);
        Console.WriteLine("Test1已经释放资源");
    }
}
public static void Test2()
{
    bool isGetLock = false;
    isGetLock = Monitor.TryEnter(obj, 500);
    if (isGetLock == false)
    {
        Console.WriteLine("锁还没有释放，我不干活了");
        return;
    }
    try
    {
        Monitor.Enter(obj, ref acquiredLock);
        for (int i = 0; i < 10; i++)
        {
            Console.WriteLine("Test2正在锁定资源");
            Thread.Sleep(1000);
        }
    }
    catch { }
    finally
    {
        if (acquiredLock)
            Monitor.Exit(obj);
        Console.WriteLine("Test2已经释放资源");
    }
}
```

如果对象已经被锁定，另一个线程使用 `Monitor.Enter` 对象，就会一直等待另一个线程解除锁定。可以通过 `Monitor.TryEnter()` 来设置等待时间，超过一段时间后，如果锁还没有释放，就会返回 false。

## 方法锁

`[MethodImpl(MethodImplOptions.Synchronized)]` 特性标记，可以让该方法只允许同时一个线程运行。

```csharp
[MethodImpl(MethodImplOptions.Synchronized)]
public void Test()
{

}
```





----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [2. 线程同步 · C# 多线程与异步](https://threads.whuanle.cn/2.thread_sync/)

Last updated：2025-08-31





