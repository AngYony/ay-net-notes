# C# 任务的异常处理



异常捕获：

- 一旦异步方法抛出（或传递出）异常，该异常会放在返回的Task对象中，并且这个Task对象的状态变为“已完成”。
- 当await调用该Task对象时，await会获得并（重新）抛出该异常，并且保留着原始的栈轨迹。
- 因此如果想要捕获异常，必须对await语句进行try捕获。



进行中的任务发生了异常，不会直接抛出来阻止主线程执行，当获取任务处理结果或者等待任务完成时，异常会重新抛出。

```c#
static void Main()
{
    Task<int> task = new Task<int>(() =>
    {
        throw new Exception("反正就想弹出一个异常");
    });
    // 执行
    task.Start();
    Console.WriteLine("任务中的异常不会直接传播到主线程");
    Thread.Sleep(TimeSpan.FromSeconds(1));

    // 当任务发生异常，获取结果时会弹出
    int number = task.Result;
    // task.Wait(); 等待任务时，如果发生异常，也会弹出
    Console.ReadKey();
}
```

为了说明多个异步方法出现错误时的异常处理情况，我们先定义一个简单的方法，如下：

```c#
//注：该方法不是最终解决方案，终极方法见下述说明
public static async void ThrowAfter(int ms, string message)
{
    await Task.Delay(ms);
    throw new Exception(message);
}
```

上述方法将在指定的时间间隔抛出一个异常。如果直接在try/catch块中调用该异步方法，并且没有等待，就会捕获不到异常，代码如下：

```c#
//注：该方法不是最终解决方案，终极方法见下述说明
public static void DontHandle()
{
    try
    {
        ThrowAfter(200, "first");
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}
```

上述的代码并不能捕获到任何异常，这是因为`DontHandle()`方法在`ThrowAfter()`抛出异常之前，就已经执行完毕。正确的做法是使用`await`关键字等待`ThrowAfter()`方法执行完才能捕获。由于`ThrowAfter()`是一个void方法，返回`void`的异步方法不能使用`await`关键字进行等待，就无法捕获异常，因此异常方法最好返回一个`Task`类型。对上述方法进行重构：

```c#
//注：终极方法
public async static Task ThrowAfter(int ms, string message)
{
    await Task.Delay(ms);
    throw new Exception(message);
}
//注：终极方法
public async static void DontHandle()
{
    try
    {
        await ThrowAfter(200, "first");
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}
```

重构后的方法可以正常的捕获抛出的异常信息。

### 多个异步方法的异常处理

上述示例针对单一的异步方法比较容易捕获，如果是多个异步方法，使用上述这种做法并不能够捕获全部的异常。

例如：

```c#
//注：该方法不是最终解决方案，终极方法见下述说明
public static async void StartTwoTask()
{
    try
    {
        await ThrowAfter(2000, "first");
        await ThrowAfter(1000, "second");
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}
```

上述代码中，在第一个`ThrowAfter()`方法抛出异常后，try/catch代码块就会捕获到异常，直接跳过第二个`ThrowAfter()`方法的执行，因此本示例只能捕获第一个方法抛出的异常，并不能够捕获第二次抛出的异常。

如果采用`Task.WhenAll()`方法并行的调用这两个`ThrowAfter()`方法，代码如下：

```c#
//注：该方法不是最终解决方案，终极方法见下述说明
public async static void StartTwoTaskParallel()
{
    try
    {
        Task t1 = ThrowAfter(2000, "first");
        Task t2 = ThrowAfter(1000, "second");
        await Task.WhenAll(t1, t2);
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
}
```

使用`Task.WhenAll`，不管任务是否抛出异常，都会等到两个任务完成。但是，如果只是单纯的使用`Task.WhenAll`，实际上并不能捕获所有的异常，上述代码只能捕获第一次调用抛出的异常，并不能捕获第二次抛出的异常。为了捕获所有的异常，需要结合使用`AggregateException`类型。

### 使用`AggregateException`信息捕获所有异常

并行调用异步方法捕获异常的终极解决方案如下：

```c#
//注：终极方案代码
public static async void ShowAggregatedException()
{
    Task taskResult = null;
    try
    {
        Task t1 = ThrowAfter(2000, "first");
        Task t2 = ThrowAfter(1000, "second");
        await (taskResult = Task.WhenAll(t1, t2));
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
        foreach(var ex1 in taskResult.Exception.InnerExceptions)
        {
            Console.WriteLine(ex1.Message);
        }
    }
}
```

通过外部任务的`Exception`属性，`Exception`属性是`AggregateException`类型的，这个类型定义了`InnerExceptions`属性，它包含了等待中的所有异常的列表，通过遍历列表，可以捕获每一次任务的异常信息。

### 全局捕获任务异常

`TaskScheduler.UnobservedTaskException` 是一个事件，其委托定义如下：

```csharp
public delegate void EventHandler<TEventArgs>(object? sender, TEventArgs e);
```

下面是一个示例：

请发布程序后，打开目录执行程序。

```csharp
    class Program
    {
        static void Main()
        {
            TaskScheduler.UnobservedTaskException += MyTaskException;

            Task.Factory.StartNew(() =>
             {
                 throw new ArgumentNullException();
             });
            Thread.Sleep(100);
            GC.Collect();
            GC.WaitForPendingFinalizers();

            Console.WriteLine("Done");
            Console.ReadKey();
        }
        public static void MyTaskException(object sender, UnobservedTaskExceptionEventArgs eventArgs)
        {
            // eventArgs.SetObserved();
            ((AggregateException)eventArgs.Exception).Handle(ex =>
            {
                Console.WriteLine("Exception type: {0}", ex.GetType());
                return true;
            });
        }
    }
```

`TaskScheduler.UnobservedTaskException` 到底怎么用，笔者不太清楚，效果难以观察。







---

References：

- 《C#高级编程（第10版）》
- [C#概念——异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/async)
- [.NET并行处理、并发和异步——异步概述](https://docs.microsoft.com/zh-cn/dotnet/standard/async)
- [C#指南——C#使用Async和await的异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/)
- 《C#7,0 核心技术指南》

- [基于任务的异步模式（TAP）：简介和概述 - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)

- [C#中利用AsyncBarrier实现多个异步任务的同时完成_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Gx4y1479f?spm_id_from=333.788.player.switch&vd_source=e3d65fed6c5d2bee448a9a010e7d9a81)

Last updated：2025-06-25
