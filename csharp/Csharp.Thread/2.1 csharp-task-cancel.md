# C# 任务的取消

 取消任务常常应用于长时间运行的后台任务。对于取消任务，.NET提供了一种标准的机制。这种机制可用于基于任务的异步模式。

> 取消框架基于协助行为，不是强制性的。一个运行时间很长的任务需要检查自己是否被取消，在这种情况下，它的工作就是清理所有已打开的资源，并结束相关工作。

如果要取消Task，需要使用如下的构造函数创建Task，传入取消令牌。

```c#
public Task StartNew(Action action, CancellationToken cancellationToken);
```

取消基于[`CancellationTokenSource`](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtokensource?view=netframework-4.7.2_)类，该类用于发送取消请求。请求发送给引用[`CancellationToken`](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken?view=netframework-4.7.2)结构类的任务，其中`CancellationToken`结构与`CancellationTokenSource`类相关联。

`CancellationTokenSource`类还支持在指定时间后才取消任务。[`CancelAfter`](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtokensource.cancelafter?view=netframework-4.7.2#System_Threading_CancellationTokenSource_CancelAfter_System_TimeSpan_)方法传入一个时间值，单位是毫秒，在该时间过后，就取消任务。

可以将`CancellationToken`传入异步方法，框架中的某些异步方法提供可以传入`CancellationToken`的重载版本，来支持取消任务。一旦取消，就会清理资源，之后抛出异常。

任务取消的常见对策：

- 抛出异常：OperationCanceledException 或者 TaskCanceledException，`if(token.IscancellationRequested) token.ThrowIfCancellationRequetsted();`
- 提前返回：Task.FromCancelled
- 善后处理：try..catch..finally，或者 CancellationTokenSource.Register()





### CancellationTokenSource

常用的成员：

- Cancel()
- IsCancellationRequested
- CancelAfter()
- ThrowIfCancellationRequested()
- ==Register()==：用于取消操作后的善后操作。可以多次注册。



~~【注：取消任务之后，都会抛出异常，可以通过调试的方式，在catch块中进行捕获对应的异常信息。】（待验证）~~

简单的取消操作，示例一：

```csharp
static void Run(CancellationToken token) {
    int i = 1;
    while (!token.IsCancellationRequested) {
        Console.WriteLine("正在执行..."+(++i));
        Thread.Sleep(1000);
    }
}

static void Sample1() {
    CancellationTokenSource cts = new CancellationTokenSource();
	// 启动一个任务
   var task=  Task.Factory.StartNew(() => {
        Run(cts.Token);
    });

    // 当在控制台输入ctrl+c是触发
    Console.CancelKeyPress += (sender, e) => {
        cts.Cancel();
        task.Wait(); //此处Wait调用必不可少，在其他任务（这里是事件）中进行了取消操作，必须在该任务中等待取消的任务完成。
    };
    // 此处wait()的调用也必不可少
    task.Wait();
    Console.WriteLine("执行完成！");
    Console.Read();
}
```

重点在于执行了Cancel()调用后，要等待要取消的任务执行完成，否则后续操作将会受影响。

示例二，任务A执行完再执行任务B，当执行任务A时，取消任务B的执行：

```csharp
static void Sample2() {

    CancellationTokenSource source = new CancellationTokenSource();
    // 启动任务A
    var task = Task.Factory.StartNew(() => {
        for (int i = 0; i < 5; i++) {
            Console.WriteLine($"启动了任务A，当前线程：{Environment.CurrentManagedThreadId}，{DateTime.Now}，执行时间需要5秒");
            Thread.Sleep(1000);
        }
    })
    // 任务A执行完，继续执行任务B
    .ContinueWith(t => {
        Console.WriteLine($"任务B，当前线程：{Environment.CurrentManagedThreadId},我是延续任务");
    }, source.Token);

    Thread.Sleep(3000);
    // 暂停三秒后取消任务B的执行，任务A仍然会执行完成
    source.Cancel();
    // 或者直接使用CancelAfter方法
    //source.CancelAfter(3000); // 在3秒后执行取消操作
    
    Console.WriteLine("主线程要取消你了...");
    Console.ReadLine();
}
```

### Task.FromCanceled()

微软文档解释：创建 Task，它因指定的取消标记进行的取消操作而完成。

这里笔者抄来了一个[示例](https://stackoverflow.com/questions/25510766/how-to-create-a-cancelled-task)：

```csharp
var token = new CancellationToken(true);
//if(token.IsCancellationRequested)
Task task = Task.FromCanceled(token);
Task<int> genericTask = Task.FromCanceled<int>(token);
```

网上很多这样的示例，但是，这个东西到底用来干嘛的？new 就行了？

带着疑问我们来探究一下，来个示例：

```csharp
        public static Task Test()
        {
            CancellationTokenSource source = new CancellationTokenSource();
            source.Cancel();
//            if(source.IsCancellationRequested)
            return Task.FromCanceled<object>(source.Token);
        }
        static void Main()
        {
            var t = Test();    // 在此设置断点，监控变量
            Console.WriteLine(t.IsCanceled);
         }
```

`Task.FromCanceled()` 可以构造一个被取消的任务。我找了很久，没有找到很好的示例，如果一个任务在开始前就被取消，那么使用 `Task.FromCanceled()` 是很不错的。



### 如何在内部取消任务

使用 `CancellationToken` 取消令牌传递参数，使任务取消。但是都是从外部传递的，这里来实现无需 `CancellationToken` 就能取消任务。

我们可以使用 `CancellationToken` 的 `ThrowIfCancellationRequested()` 方法抛出 `System.OperationCanceledException` 异常，然后终止任务，任务会变成取消状态，不过任务需要先传入一个令牌。

示例如下：

```csharp
/// <summary>
/// 能够完成多个任务的异步类型
/// </summary>
public class MyTaskClass
{
    private List<Action> _actions = new List<Action>();
    private CancellationTokenSource _source = new CancellationTokenSource();
    private CancellationTokenSource _sourceBak = new CancellationTokenSource();
    private Task _task;

    /// <summary>
    ///  添加一个任务
    /// </summary>
    /// <param name="action"></param>
    public void AddTask(Action action)
    {
        _actions.Add(action);
    }

    /// <summary>
    /// 开始执行任务
    /// </summary>
    /// <returns></returns>
    public Task StartAsync()
    {
        // _ = new Task() 对本示例无效
        _task = Task.Factory.StartNew(() =>
         {
             for (int i = 0; i < _actions.Count; i++)
             {
                 int tmp = i;
                 Console.WriteLine($"第 {tmp} 个任务");
                 if (_source.Token.IsCancellationRequested)
                 {
                     Console.ForegroundColor = ConsoleColor.Red;
                     Console.WriteLine("任务已经被取消");
                     Console.ForegroundColor = ConsoleColor.White;
                     _sourceBak.Cancel();
                     //此处抛出异常
                     _sourceBak.Token.ThrowIfCancellationRequested();
                 }
                 _actions[tmp].Invoke();
             }
         },_sourceBak.Token);
        return _task;
    }

    /// <summary>
    /// 取消任务
    /// </summary>
    /// <returns></returns>
    public Task Cancel()
    {
        _source.Cancel();

        // 这里可以省去
        _task = Task.FromCanceled<object>(_source.Token);
        return _task;
    }
}
```

Main 方法中：

```csharp
static void Main()
{
    // 实例化任务类
    MyTaskClass myTask = new MyTaskClass();

    for (int i = 0; i < 10; i++)
    {
        int tmp = i;
        myTask.AddTask(() =>
        {
            Console.WriteLine("     任务 1 Start");
            Thread.Sleep(TimeSpan.FromSeconds(1));
            Console.WriteLine("     任务 1 End");
            Thread.Sleep(TimeSpan.FromSeconds(1));
        });
    }

    // 相当于 Task.WhenAll()
    Task task = myTask.StartAsync();
    Thread.Sleep(TimeSpan.FromSeconds(1));
    Console.WriteLine($"任务是否被取消：{task.IsCanceled}");

    // 取消任务
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine("按下任意键可以取消任务");
    Console.ForegroundColor = ConsoleColor.White;
    Console.ReadKey();

    var t = myTask.Cancel();    // 取消任务
    Thread.Sleep(TimeSpan.FromSeconds(2));
    Console.WriteLine($"任务是否被取消：【{task.IsCanceled}】");

    Console.ReadKey();
}
```

你可以在任一阶段取消任务。

示例二，同样抛出异常：

```csharp
public static void CancelTask()
{
    var cts = new CancellationTokenSource();
    cts.Token.Register(() => { Console.WriteLine("--- task cancelled"); });

    cts.CancelAfter(500);
    try
    {
        Task t1 = Task.Run(() =>
        {
            Console.WriteLine("in task");
            for (int i = 0; i < 20; i++)
            {
                Task.Delay(100).Wait();
                CancellationToken token = cts.Token;
                //是否请求了取消
                if (token.IsCancellationRequested)
                {
                    Console.WriteLine("得到取消请求");
                    //执行取消并直接抛出异常
                    token.ThrowIfCancellationRequested();
                    break;
                }
                Console.WriteLine("in loop");
            }
            Console.WriteLine("任务完成，没有取消");
        }, cts.Token); //把取消标记赋予TaskFactory

        t1.Wait();
    }
    catch (AggregateException ex)
    {
        Console.WriteLine($"异常：{ex.GetType().Name},{ex.Message}");
        foreach (var innerException in ex.InnerExceptions)
        {
            Console.WriteLine($"异常详情：{ex.InnerException.GetType()}, {ex.InnerException.Message}");
        }
    }
}
```

上述示例中，一旦取消任务，会抛出`TaskCanceledException`异常，它是从方法调用`ThrowifCancellationRequested()`中启动的。调用者等待任务时，会捕获`AggregateException`异常，它包含内部异常`TaskCanceledException`。

如果在一个也被取消的任务中运行`Parallel.For()`方法，这就可以用于取消的层次结构，任务的最终状态是`Canceled`。

上述示例执行结果：

```
in task
in loop
in loop
in loop
in loop
--- task cancelled
得到取消请求
异常：AggregateException,发生一个或多个错误。
异常详情：System.Threading.Tasks.TaskCanceledException, 已取消一个任务。
-----程序执行完毕-----
```





### 延迟取消与注册取消通知

#### 延迟取消

延迟取消调用的是source.Cancel()方法。上诉代码中，在执行任务B时，会检测source.Token，当发现已取消时，将不再执行。

```
Thread.Sleep(3000);
source.Cancel();
```

可以直接用下述代码替代：

```csharp
source.CancelAfter(3000); // 在3秒后执行取消操作
```

详细代码见下文。

#### 注册取消通知

核心在于调用source.Token.Register()方法。

综合示例：

```csharp
static void Sample2() {

    CancellationTokenSource source = new CancellationTokenSource();
    // 启动任务A
    var task = Task.Factory.StartNew(() => {
        for (int i = 0; i < 5; i++) {
            Console.WriteLine($"启动了任务A，当前线程：{Environment.CurrentManagedThreadId}，{DateTime.Now}，执行时间需要5秒");
            Thread.Sleep(1000);
        }
        
    })
    // 任务A执行完，继续执行任务B
    .ContinueWith(t => {
        Console.WriteLine($"任务B，当前线程：{Environment.CurrentManagedThreadId},我是延续任务");
    }, source.Token);

    //Thread.Sleep(3000);
    //// 暂停三秒后取消任务B的执行，任务A仍然会执行完成
    //source.Cancel();

    source.CancelAfter(3000); // 在3秒后执行取消操作
    //取消回调
    source.Token.Register(() => {
        Console.WriteLine("取消啦，我是回调函数！");
    });

    Console.WriteLine("主线程要取消你了...");
    Console.ReadLine();
}
```





---

References：

- 《C#高级编程（第10版）》
- [C#概念——异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/async)
- [.NET并行处理、并发和异步——异步概述](https://docs.microsoft.com/zh-cn/dotnet/standard/async)
- [C#指南——C#使用Async和await的异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/)
- 《C#7,0 核心技术指南》

- [基于任务的异步模式（TAP）：简介和概述 - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)

- [C#中利用AsyncBarrier实现多个异步任务的同时完成_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Gx4y1479f?spm_id_from=333.788.player.switch&vd_source=e3d65fed6c5d2bee448a9a010e7d9a81)

Last updated：2025-06-25
