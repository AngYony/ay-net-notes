# C# 任务的取消

 取消任务常常应用于长时间运行的后台任务。对于取消任务，.NET提供了一种标准的机制。这种机制可用于基于任务的异步模式。

> 取消框架基于协助行为，不是强制性的。一个运行时间很长的任务需要检查自己是否被取消，在这种情况下，它的工作就是清理所有已打开的资源，并结束相关工作。

如果要取消Task，需要在开启Task的时候，传入取消令牌CancellationToken对象。

```c#
public Task StartNew(Action action, CancellationToken cancellationToken);
```

CancellationToken对象来自于CancellationTokenSource类的Token属性。

这里先从最简单的CancellationToken来介绍，它的作用是传播有关应该进行取消操作的通知。通俗点来说，就是通过该对象可以判断任务是否被取消掉了。 



## CancellationToken

[CancellationToken](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken?view=netframework-4.8) 的定义如下：

```
public struct CancellationToken
```

可以看到CancellationToken是结构类型，因此它的成员非常简单。

### CancellationToken 常用属性

#### IsCancellationRequested

当接受到取消通知时，该属性的值为true，否则为false，因此通常需要在false的情况下，执行业务原子性操作。

例如：

```csharp
static void Run(CancellationToken token) {
    int i = 1;
    while (!token.IsCancellationRequested) {
        Console.WriteLine("正在执行..."+(++i));
        Thread.Sleep(1000);
    }
}
```

所谓的业务原子型操作，就是要在`if(!token.IsCancellationRequested)`代码块中，不要有其他的业务或者不能及时处理完的操作。如果有多个不同业务的操作，需要进行多次`if(!token.IsCancellationRequested)`的判断。

#### None

返回一个空 CancellationToken 值。

### CancellationToken 常用方法

#### `Register(Action<Object>, Object, Boolean)`

用于取消操作后的善后操作。可以多次注册。

该方法注册的行为是否执行受CancellationTokenSource 的 Cancel (bool throwOnFirstException) 方法影响，当Cancel(bool)中的参数为true时，表示异常将立即进行传播，即马上向上抛出异常，从而阻止注册的回调的执行。

示例：

```csharp
static void Sample2() {

    CancellationTokenSource source = new CancellationTokenSource();
    // 启动任务A
    var task = Task.Factory.StartNew(() => {
        for (int i = 0; i < 5; i++) {
            Console.WriteLine($"启动了任务A，当前线程：{Environment.CurrentManagedThreadId}，{DateTime.Now}，执行时间需要5秒");
            Thread.Sleep(1000);
        }
        
    })
    // 任务A执行完，继续执行任务B
    .ContinueWith(t => {
        Console.WriteLine($"任务B，当前线程：{Environment.CurrentManagedThreadId},我是延续任务");
    }, source.Token);

    //Thread.Sleep(3000);
    //// 暂停三秒后取消任务B的执行，任务A仍然会执行完成
    //source.Cancel();

    source.CancelAfter(3000); // 在3秒后执行取消操作
    //取消回调
    source.Token.Register(() => {
        Console.WriteLine("取消啦，我是回调函数！");
    });

    Console.WriteLine("主线程要取消你了...");
    Console.ReadLine();
}
```



#### ThrowIfCancellationRequested()

该方法通常用在任务的内部，如果接收到任务取消的通知时，马上抛出任务取消的异常来终止任务的执行。

该方法等同于：

```csharp
if (token.IsCancellationRequested)   
    throw new OperationCanceledException(token); 
```

因此在使用该方法时，可以不需要进行token.IsCancellationRequested的判断，而直接使用。

例如：

```csharp
//if语句可以省略不需要
if(token.IsCancellationRequested)
{
	//接收到任务取消通知后，马上终止任务。
	token.ThrowIfCancellationRequested();
}
```

由于抛出了异常，因此使用该方法时，还需要在任务的外部进行取消异常的捕获。见下文示例。



## CancellationTokenSource

上文中的CancellationToken是用来传递任务取消的通知的，而真正执行任务取消操作的，则是由CancellationTokenSource来触发的。

### CancellationTokenSource 构造函数

CancellationTokenSource  有以下三个重载构造函数：

```csharp
public CancellationTokenSource ();
public CancellationTokenSource (int millisecondsDelay);
public CancellationTokenSource (TimeSpan delay);
```



### CancellationTokenSource 常用属性

#### Token

获取与此CancellationTokenSource关联的CancellationToken。通常用于任务中的取消通知传递。

#### IsCancellationRequested

获取是否已请求取消此 CancellationTokenSource。取消为true，否则为false。



### CancellationTokenSource 常用方法

这里以参数最复杂的重载方法进行说明。

#### Cancel(Boolean)

如果出现异常，传达取消请求，并指定是否应处理其余回调和可取消操作。

当Cancel(bool)中的参数为true时，表示异常将立即进行传播，即马上向上抛出异常，从而阻止注册的回调的执行。

#### CancelAfter(TimeSpan)、CancelAfter(Int32)

在指定的时间之后执行取消操作，即延时取消。

#### CreateLinkedTokenSource(CancellationToken[])

创建一个 CancellationTokenSource，当任何源令牌处于已取消状态时，该状态将处于取消状态。



## Task.FromCanceled()

微软文档解释：创建 Task，它因指定的取消标记进行的取消操作而完成。

示例：

```csharp
var token = new CancellationToken(true);
//if(token.IsCancellationRequested)
Task task = Task.FromCanceled(token);
Task<int> genericTask = Task.FromCanceled<int>(token);
```

更常见的用法：

```csharp
        public static Task Test()
        {
            CancellationTokenSource source = new CancellationTokenSource();
            source.Cancel();
//            if(source.IsCancellationRequested)
            return Task.FromCanceled<object>(source.Token);
        }
        static void Main()
        {
            var t = Test();    // 在此设置断点，监控变量
            Console.WriteLine(t.IsCanceled);
         }
```





## 实战示例

### 示例一：任务的简单取消操作

```csharp
static void Run(CancellationToken token) {
    int i = 1;
    while (!token.IsCancellationRequested) {
        Console.WriteLine("正在执行..."+(++i));
        Thread.Sleep(1000);
    }
}

static void Sample1() {
    CancellationTokenSource cts = new CancellationTokenSource();
	// 启动一个任务
   var task=  Task.Factory.StartNew(() => {
        Run(cts.Token);
    });

    // 当在控制台输入ctrl+c是触发
    Console.CancelKeyPress += (sender, e) => {
        cts.Cancel();
        task.Wait(); //此处Wait调用必不可少，在其他任务（这里是事件）中进行了取消操作，必须在该任务中等待取消的任务完成。
    };
    // 此处wait()的调用也必不可少
    task.Wait();
    Console.WriteLine("执行完成！");
    Console.Read();
}
```

重点在于执行了Cancel()调用后，要等待要取消的任务执行完成，否则后续操作将会受影响。

### 示例二：在任务的内部取消任务

核心就是使用 `CancellationToken` 的 `ThrowIfCancellationRequested()` 方法抛出 `System.OperationCanceledException` 异常，然后终止任务。

```csharp
public static void CancelTask()
{
    var cts = new CancellationTokenSource();
    cts.Token.Register(() => { Console.WriteLine("--- task cancelled"); });

    cts.CancelAfter(500);
    try
    {
        Task t1 = Task.Run(() =>
        {
            Console.WriteLine("in task");
            for (int i = 0; i < 20; i++)
            {
                Task.Delay(100).Wait();
                CancellationToken token = cts.Token;
                //是否请求了取消
                if (token.IsCancellationRequested)
                {
                    Console.WriteLine("得到取消请求");
                    //执行取消并直接抛出异常
                    token.ThrowIfCancellationRequested();
                    break;
                }
                Console.WriteLine("in loop");
            }
            Console.WriteLine("任务完成，没有取消");
        }, cts.Token); //把取消标记赋予TaskFactory

        t1.Wait();
    }
    catch (AggregateException ex)
    {
        Console.WriteLine($"异常：{ex.GetType().Name},{ex.Message}");
        foreach (var innerException in ex.InnerExceptions)
        {
            Console.WriteLine($"异常详情：{ex.InnerException.GetType()}, {ex.InnerException.Message}");
        }
    }
}
```

上述示例中，一旦取消任务，会抛出`TaskCanceledException`异常，它是从方法调用`ThrowifCancellationRequested()`中启动的。调用者等待任务时，会捕获`AggregateException`异常，它包含内部异常`TaskCanceledException`。

如果在一个也被取消的任务中运行`Parallel.For()`方法，这就可以用于取消的层次结构，任务的最终状态是`Canceled`。

上述示例执行结果：

```
in task
in loop
in loop
in loop
in loop
--- task cancelled
得到取消请求
异常：AggregateException,发生一个或多个错误。
异常详情：System.Threading.Tasks.TaskCanceledException, 已取消一个任务。
-----程序执行完毕-----
```







---

References：

- 《C#高级编程（第10版）》
- [C#概念——异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/async)
- [.NET并行处理、并发和异步——异步概述](https://docs.microsoft.com/zh-cn/dotnet/standard/async)
- [C#指南——C#使用Async和await的异步编程](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/)
- 《C#7,0 核心技术指南》

- [基于任务的异步模式（TAP）：简介和概述 - .NET | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)

- [C#中利用AsyncBarrier实现多个异步任务的同时完成_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Gx4y1479f?spm_id_from=333.788.player.switch&vd_source=e3d65fed6c5d2bee448a9a010e7d9a81)

Last updated：2025-09-23
