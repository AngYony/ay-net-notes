# C# 线程同步——信号量（Semaphore，非排它锁）

信号量分为两种类型：本地信号量和命名系统信号量。

- 命名系统信号量在整个操作系统中均可见，可用于同步进程的活动。
- 局部信号量仅存在于进程内。

当 name 为 null 或者为空时，Mutex 的信号量时局部信号量，否则 Mutex 的信号量是命名系统信号量。Semaphore 的话，也是两种方式都有。

如果使用接受名称的构造函数创建 Semaphore 对象，则该对象将与该名称的操作系统信号量关联。

两个构造函数：

```csharp
Semaphore(Int32, Int32, String)
Semaphore(Int32, Int32, String, Boolean)
```

上面的构造函数可以创建多个表示同一命名系统信号量的 Semaphore 对象，并可以使用 OpenExisting 方法打开现有的已命名系统信号量。

我们上面使用的示例就是局部信号量，进程中引用本地 Semaphore 对象的所有线程都可以使用。 每个 Semaphore 对象都是单独的本地信号量。

可以利用 Semaphore 限制一个程序最多能够同时运行多少个。





使用`Semaphore`，可以定义允许同时访问资源的线程个数。如果需要限制可以访问可用资源的线程数，`Semaphore`就很有用。

Semaphore类似于俱乐部：它有特定的容量（允许同时访问的线程数），允许人进入之后锁定席位（Wait方法），一旦满员之后，就不允许其他人（其他线程）进入了，只能在外面排队。每当有人离开时（Release方法），才准许另外一个人进入。

信号量有两个功能相似的实现：Semaphore 和 SemaphoreSlim。两者都可以限制同时访问某一资源或资源池的线程数，实现并发时限制具体数量的线程进行并发操作。

SemaphoreSlim 表示对可同时访问资源或资源池的线程数加以限制的 Semaphore 的轻量替代。SemaphoreSlim是在 .NET Fx4.0 引入的，它进行了一些优化以适应并行编程对低延迟的需求。

SemaphoreSlim的限制：SemaphoreSlim 不使用信号量，不支持进程间同步，只能在进程内使用。SemaphoreSlim不能用于进程间通信。

与 lock 不同的时，Semaphore 允许多个线程同时执行相同的区域代码，因此称为非排他锁。





### Semaphore 类

Semaphore的构造函数如下：

| 构造函数                                 | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| Semaphore(Int32, Int32)                  | 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口数。 |
| Semaphore(Int32, Int32, String)          | 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口数，根据需要指定系统信号灯对象的名称。 |
| Semaphore(Int32, Int32, String, Boolean) | 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口数，还可以选择指定系统信号量对象的名称，以及指定一个变量来接收指示是否创建了新系统信号量的值。 |

在`SemaphoreSlim`类的构造方法中，第一个参数定义了最初释放的锁定数，第二个参数定义了锁定个数的计数。如果第一个参数的值小于第二个参数，它们的差就是已经分配线程的计数值。与互斥一样，可以给信号量指定名称，使之在不同的进程之间共享。如果定义信号量时没有指定名称，只能在这个进程中使用。

Semaphore 使用纯粹的内核时间(kernel-time)方式(等待时间很短)，并且支持在不同的进程间同步线程(像Mutex)。

以下述构造函数为例：

```
public Semaphore(int initialCount, int maximumCount);
```

- initialCount 表示一开始允许几个进程进入资源池，如果设置为0，所有线程都不能进入，要一直等资源池放通。

- maximumCount 表示最大允许几个线程进入资源池。

Semaphore 常用方法如下：

| 方法                               | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| Close()                            | 释放由当前 WaitHandle占用的所有资源。                        |
| OpenExisting(String)               | 打开指定名称为信号量（如果已经存在）。                       |
| Release()                          | 退出信号量并返回前一个计数。                                 |
| Release(Int32)                     | 以指定的次数退出信号量并返回前一个计数。                     |
| TryOpenExisting(String, Semaphore) | 打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。 |
| WaitOne()                          | 阻止当前线程，直到当前 WaitHandle 收到信号。                 |
| WaitOne(Int32)                     | 阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。 |
| WaitOne(Int32, Boolean)            | 阻止当前线程，直到当前的 WaitHandle 收到信号为止，同时使用 32 位带符号整数指定时间间隔，并指定是否在等待之前退出同步域。 |
| WaitOne(TimeSpan)                  | 阻止当前线程，直到当前实例收到信号，同时使用 TimeSpan 指定时间间隔。 |
| WaitOne(TimeSpan, Boolean)         | 阻止当前线程，直到当前实例收到信号为止，同时使用 TimeSpan 指定时间间隔，并指定是否在等待之前退出同步域。 |

使用 Semaphore ，有四个步骤：

1. new 实例化 Semaphore，并设置最大线程数、初始化时可进入线程数；
2. 使用 `.WaitOne();` 获取进入权限(在获得进入权限前，线程处于阻塞状态)。
3. 离开时使用 `Release()` 释放占用。
4. `Close()` 释放Semaphore 对象。

#### Semaphore 示例

简单示例：

```csharp
static void Main(string[] args)
{
    for (int i = 0; i < 5; i++)
    {
        new Thread((a) =>
        {
            Console.WriteLine(a + "想要进入资源池");
            //阻塞当前线程，直到收到信号获取到进入权限
            _sem.Wait();
            Console.WriteLine(a + "已经进入");
            Thread.Sleep((int)a * 1000);
            Console.WriteLine(a + "正在离开");
            //可以将此行代码注释看看效果
            _sem.Release();
        }).Start(i);
    }
}
```

运行结果：

```
0想要进入资源池
1想要进入资源池
0已经进入
0正在离开
4想要进入资源池
4已经进入
1已经进入
2想要进入资源池
2已经进入
3想要进入资源池
1正在离开
3已经进入
2正在离开
4正在离开
3正在离开
```

示例二，采用多个线程执行计算，但是只允许最多三个线程同时执行运行。

```csharp
class Program
    {
        // 求和
        private static int sum = 0;
        private static Semaphore _pool;

        // 判断十个线程是否结束了。
        private static int isComplete = 0;
        // 第一个程序
        static void Main(string[] args)
        {
            Console.WriteLine("执行程序");

            // 设置允许最大三个线程进入资源池
            // 一开始设置为0，就是初始化时允许几个线程进入
            // 这里设置为0，后面按下按键时，可以放通三个线程
            _pool = new Semaphore(0, 3);
            for (int i = 0; i < 10; i++)
            {
                Thread thread = new Thread(new ParameterizedThreadStart(AddOne));
                thread.Start(i + 1);
            }
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("任意按下键(不要按关机键)，可以打开资源池");
            Console.ForegroundColor = ConsoleColor.White;
            Console.ReadKey();

            // 准许三个线程进入
            _pool.Release(3);

            // 这里没有任何意义，就单纯为了演示查看结果。
            // 等待所有线程完成任务
            while (true)
            {
                if (isComplete >= 10)
                    break;
                Thread.Sleep(TimeSpan.FromSeconds(1));
            }
            Console.WriteLine("sum = " + sum);

            // 释放池
            _pool.Close();

        }

        public static void AddOne(object n)
        {
            Console.WriteLine($"    线程{(int)n}启动，进入队列");
            // 进入队列等待
            _pool.WaitOne();
            Console.WriteLine($"第{(int)n}个线程进入资源池");
            // 进入资源池
            for (int i = 0; i < 10; i++)
            {
                Interlocked.Add(ref sum, 1);
                Thread.Sleep(TimeSpan.FromMilliseconds(500));
            }
            // 解除占用的资源池
            _pool.Release();
            isComplete += 1;
            Console.WriteLine($"                     第{(int)n}个线程退出资源池");
        }
    }
```

运行效果：

![Semaphoregif](./assets/Semaphoregif.gif)

`Release()` 表示退出信号量并返回前一个计数。这个计数指的是资源池还可以进入多少个线程。

可以看一下下面的示例：

```csharp
private static Semaphore _pool;
static void Main(string[] args)
{
    _pool = new Semaphore(0, 5);
    _pool.Release(5);
    new Thread(AddOne).Start();
    Thread.Sleep(TimeSpan.FromSeconds(10));
    _pool.Close();
}

public static void AddOne()
{
    _pool.WaitOne();
    Thread.Sleep(1000);
    int count = _pool.Release();
    Console.WriteLine("在此线程退出资源池前，资源池还有多少线程可以进入？" + count);
}
```



### SemaphoreSlim 类

SemaphoreSlim 表示对可同时访问资源或资源池的线程数加以限制的 Semaphore 的轻量替代。

SemaphoreSlim 不使用信号量，不支持进程间同步，只能在进程内使用。

它有两个构造函数：

| 构造函数                    | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| SemaphoreSlim(Int32)        | 初始化 SemaphoreSlim 类的新实例，以指定可同时授予的请求的初始数量。 |
| SemaphoreSlim(Int32, Int32) | 初始化 SemaphoreSlim 类的新实例，同时指定可同时授予的请求的初始数量和最大数量。 |

我们改造一下前面 Semaphore 中的示例：

```csharp
    class Program
    {
        // 求和
        private static int sum = 0;
        private static SemaphoreSlim _pool;

        // 判断十个线程是否结束了。
        private static int isComplete = 0;
        static void Main(string[] args)
        {
            Console.WriteLine("执行程序");

            // 设置允许最大三个线程进入资源池
            // 一开始设置为0，就是初始化时允许几个线程进入
            // 这里设置为0，后面按下按键时，可以放通三个线程
            _pool = new SemaphoreSlim(0, 3);
            for (int i = 0; i < 10; i++)
            {
                Thread thread = new Thread(new ParameterizedThreadStart(AddOne));
                thread.Start(i + 1);
            }

            Console.WriteLine("任意按下键(不要按关机键)，可以打开资源池");
            Console.ReadKey();
            // 
            _pool.Release(3);

            // 这里没有任何意义，就单纯为了演示查看结果。
            // 等待所有线程完成任务
            while (true)
            {
                if (isComplete >= 10)
                    break;
                Thread.Sleep(TimeSpan.FromSeconds(1));
            }
            Console.WriteLine("sum = " + sum);
            // 释放池
        }

        public static void AddOne(object n)
        {
            Console.WriteLine($"    线程{(int)n}启动，进入队列");
            // 进入队列等待
            _pool.Wait();
            Console.WriteLine($"第{(int)n}个线程进入资源池");
            // 进入资源池
            for (int i = 0; i < 10; i++)
            {
                Interlocked.Add(ref sum, 1);
                Thread.Sleep(TimeSpan.FromMilliseconds(200));
            }
            // 解除占用的资源池
            _pool.Release();
            isComplete += 1;
            Console.WriteLine($"                     第{(int)n}个线程退出资源池");
        }
    }
```

SemaphoreSlim 不需要 `Close()`。

示例二，来自于《C#高级编程》：

```c#
static void TaskMain(SemaphoreSlim semaphore)
{
    bool isCompleted = false;
    while (!isCompleted)
    {
        //锁定信号量，定义最长等待时间为600毫秒
        if (semaphore.Wait(600))
        {
            try
            {
                Console.WriteLine($"Task {Task.CurrentId} locks the semaphore");
                Task.Delay(2000).Wait();
            }
            finally
            {
                Console.WriteLine($"Task {Task.CurrentId} releases the semaphore");
                semaphore.Release();
                isCompleted = true;
            } 
        }
        else{
            Console.WriteLine($"Timeout for task {Task.CurrentId}; wait again");
        }
    }
}

public static void Run()
{
    int taskCount = 6;
    int semaphoreCount = 3;
    //创建计数为3的信号量
    //该构造函数第一个参数表示最初释放的锁定量，第二个参数定义了锁定个数的计数
    var semaphore = new SemaphoreSlim(semaphoreCount, semaphoreCount);
    var tasks = new Task[taskCount];
    for(int i = 0; i < taskCount; i++)
    {
        tasks[i] = Task.Run(()=>TaskMain(semaphore));
    }

    Task.WaitAll(tasks);
    Console.WriteLine("All tasks finished");
}
```

> 上述代码中的`Run()`方法中，创建了6个任务和一个计数为3的信号量。在`SemaphoreSlim`类的构造方法中，第一个参数定义了最初释放的锁定数，第二个参数定义了锁定个数的计数。如果第一个参数的值小于第二个参数，它们的差就是已经分配线程的计数值。与互斥一样，可以给信号量指定名称，使之在不同的进程之间共享。实例中，定义信号量时没有指定名称，所以它只能在这个进程中使用。
>
> 上述代码中的`TaskMain()`方法中，任务利用`Wait()`方法锁定信号量。信号量的计数是3，所以有3个任务可以获得锁定。第4个任务必须等待，这里还定义了最长等待时间为600毫秒。如果在该等待时间过后未能获得锁定，任务就把一条消息写入控制台，在循环中继续等待。只要获得了锁定，任务就把一条消息写入控制台，等待一段时间，然后解除锁定。在解除锁定时，在任何情况下一定要解除资源的锁定，这一点很重要。这就是要在`finally`处理程序中调用`SemaphoreSlim.Release()`方法的原因。

上述代码执行后，输出结果如下：

```
Task 3 locks the semaphore
Task 2 locks the semaphore
Task 1 locks the semaphore
Timeout for task 4; wait again
Timeout for task 4; wait again
Timeout for task 5; wait again
Timeout for task 4; wait again
Task 1 releases the semaphore
Task 9 locks the semaphore
Task 3 releases the semaphore
Task 5 locks the semaphore
Task 2 releases the semaphore
Task 4 locks the semaphore
Task 4 releases the semaphore
Task 5 releases the semaphore
Task 9 releases the semaphore
All tasks finished
-----程序执行完毕-----
```



### SemaphoreSlim 与 Semaphore 的区别

如果使用下面的构造函数实例化 Semaphore(参数name不能为空)，那么**创建的对象在整个操作系统内都有效**。

```csharp
public Semaphore (int initialCount, int maximumCount, string name);
```

Semaphorslim 则只在进程内有效，SemaphoreSlim 是对 Semaphore 的简单封装。

SemaphoreSlim 类不会对 `Wait`、`WaitAsync` 和 `Release` 方法的调用强制执行线程或任务标识。

而 Semaphor 类，会对此进行严格监控，如果对应调用数量不一致，会出现异常。

此外，如果使用 SemaphoreSlim(Int32 maximumCount) 构造函数来实例化 SemaphoreSlim 对象，获取其 CurrentCount 属性，其值可能会大于 maximumCount。 编程人员应负责确保调用一个 Wait 或 WaitAsync 方法，便调用一个 Release。

这就好像笔筒里面的笔，没有监控，使用这使用完毕后，都应该将笔放进去。如果原先有10支笔，每次使用不放进去，或者将别的地方的笔放进去，那么最后数量就不是10了。因此使用时需要注意捕获异常，合理释放锁。





----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [2. 线程同步 · C# 多线程与异步](https://threads.whuanle.cn/2.thread_sync/)

Last updated：2025-08-31





