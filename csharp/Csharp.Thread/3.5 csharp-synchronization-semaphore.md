# C# 线程同步——Semaphore 和 SemaphoreSlim

这两个类主要用于控制并发进程或线程的数量，它允许多个线程同时执行相同的区域代码，因此称为非排他锁。

类似于电影院观影厅：它有特定的容量座位（允许同时访问的线程数），允许人进入之后锁定席位（Wait方法），一旦满员之后，就不允许其他人（其他线程）进入了，只能在外面排队。每当有人离开时（Release方法），才准许另外一个人进入。

注：这两个类中文被翻译为“信号量”或“信号灯”。



## Semaphore 类

[Semaphore 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphore?view=netframework-4.8)

### Semaphore 构造函数

Semaphore 有多个重载的构造函数，这里对其中参数最多的一个进行介绍：

[Semaphore(Int32, Int32, String, Boolean, SemaphoreSecurity)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphore.-ctor?view=netframework-4.8#system-threading-semaphore-ctor(system-int32-system-int32-system-string-system-boolean@-system-security-accesscontrol-semaphoresecurity))：

```csharp
public Semaphore (
    int initialCount, 
    int maximumCount, 
    string name, 
    out bool createdNew, 
    System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);
```

- initialCount：初始入口数，指定初始允许多少个线程进入。
- maximumCount：最大并发入口数，指定最多允许多少个线程同时处理。
- name：和Mutex一样，当 name 为 null 或者为空时，为**本地局部信号量**，不允许跨进程访问，只允许该进程中的线程访问；当name指定了具体名称时，将被定义为**命名系统信号量**，该对象将与该名称的操作系统信号量关联，使之在不同的进程之间共享。
- createdNew：在此方法返回时，如果创建了本地信号量（即，如果 name 为 null 或空字符串）或指定的命名系统信号量，则包含 true；如果指定的命名系统信号量已存在，则为 false。
- 一个 SemaphoreSecurity 对象，表示应用于已命名的系统信号量的访问控制安全性。



### Semaphore 常用方法

[Semaphore 常用方法](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphore?view=netframework-4.8#methods) 如下：

| 方法                               | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| Close()                            | 释放由当前 WaitHandle占用的所有资源。                        |
| OpenExisting(String)               | 打开指定名称为信号量（如果已经存在）。                       |
| Release()                          | 退出信号量并返回前一个计数。                                 |
| Release(Int32)                     | 以指定的次数退出信号量并返回前一个计数。                     |
| TryOpenExisting(String, Semaphore) | 打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。 |
| WaitOne()                          | 阻止当前线程，直到当前 WaitHandle 收到信号。                 |
| WaitOne(Int32)                     | 阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。 |
| WaitOne(Int32, Boolean)            | 阻止当前线程，直到当前的 WaitHandle 收到信号为止，同时使用 32 位带符号整数指定时间间隔，并指定是否在等待之前退出同步域。 |
| WaitOne(TimeSpan)                  | 阻止当前线程，直到当前实例收到信号，同时使用 TimeSpan 指定时间间隔。 |
| WaitOne(TimeSpan, Boolean)         | 阻止当前线程，直到当前实例收到信号为止，同时使用 TimeSpan 指定时间间隔，并指定是否在等待之前退出同步域。 |

- [WaitOne(TimeSpan, Boolean)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.waithandle.waitone?view=netframework-4.8#system-threading-waithandle-waitone(system-timespan-system-boolean))：阻止当前线程，直到当前实例收到信号为止，同时使用 TimeSpan 指定时间间隔，并指定是否在等待之前退出同步域。(继承自 WaitHandle)。
- [Release(Int32)](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphore.release?view=netframework-4.8#system-threading-semaphore-release(system-int32))：表示退出信号量并返回前一个计数。这个计数指的是资源池还可以进入多少个线程。

### Semaphore 实战

使用 Semaphore ，有四个步骤：

1. new 实例化 Semaphore，并设置最大线程数、初始化时可进入线程数；
2. 使用 `.WaitOne();` 获取进入权限(在获得进入权限前，线程处于阻塞状态)。
3. 离开时使用 `Release()` 释放占用。
4. `Close()` 释放Semaphore 对象。

#### Semaphore 示例

采用多个线程执行计算，但是只允许最多三个线程同时执行运行。

```csharp
class Program
    {
        // 求和
        private static int sum = 0;
        private static Semaphore _pool;

        // 判断十个线程是否结束了。
        private static int isComplete = 0;
        // 第一个程序
        static void Main(string[] args)
        {
            Console.WriteLine("执行程序");

            // 设置允许最大三个线程进入资源池
            // 一开始设置为0，就是初始化时允许几个线程进入
            // 这里设置为0，后面按下按键时，可以放通三个线程
            _pool = new Semaphore(0, 3);
            for (int i = 0; i < 10; i++)
            {
                Thread thread = new Thread(new ParameterizedThreadStart(AddOne));
                thread.Start(i + 1);
            }
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("任意按下键(不要按关机键)，可以打开资源池");
            Console.ForegroundColor = ConsoleColor.White;
            Console.ReadKey();

            // 准许三个线程进入
            _pool.Release(3);

            // 这里没有任何意义，就单纯为了演示查看结果。
            // 等待所有线程完成任务
            while (true)
            {
                if (isComplete >= 10)
                    break;
                Thread.Sleep(TimeSpan.FromSeconds(1));
            }
            Console.WriteLine("sum = " + sum);

            // 释放池
            _pool.Close();

        }

        public static void AddOne(object n)
        {
            Console.WriteLine($"    线程{(int)n}启动，进入队列");
            // 进入队列等待
            _pool.WaitOne();
            Console.WriteLine($"第{(int)n}个线程进入资源池");
            // 进入资源池
            for (int i = 0; i < 10; i++)
            {
                Interlocked.Add(ref sum, 1);
                Thread.Sleep(TimeSpan.FromMilliseconds(500));
            }
            // 解除占用的资源池
            _pool.Release();
            isComplete += 1;
            Console.WriteLine($"                     第{(int)n}个线程退出资源池");
        }
    }
```

运行效果：

![Semaphoregif](./assets/Semaphoregif.gif)

`Release()` 表示退出信号量并返回前一个计数。这个计数指的是资源池还可以进入多少个线程。

可以看一下下面的示例：

```csharp
private static Semaphore _pool;
static void Main(string[] args)
{
    _pool = new Semaphore(0, 5);
    _pool.Release(5);
    new Thread(AddOne).Start();
    Thread.Sleep(TimeSpan.FromSeconds(10));
    _pool.Close();
}

public static void AddOne()
{
    _pool.WaitOne();
    Thread.Sleep(1000);
    int count = _pool.Release();
    Console.WriteLine("在此线程退出资源池前，资源池还有多少线程可以进入？" + count);
}
```



## SemaphoreSlim 类

[SemaphoreSlim 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphoreslim?view=netframework-4.8)

SemaphoreSlim是在 .NET Fx4.0 引入的，它进行了一些优化以适应并行编程对低延迟的需求，它是 Semaphore 的轻量替代。

与 Semaphore 不同的是， SemaphoreSlim 类不支持命名的系统信号量，只能将其用作本地信号量。即 SemaphoreSlim 只能用来限制进程中的线程数，不支持进程间同步，只能在进程内使用。



### SemaphoreSlim 构造函数

[SemaphoreSlim 构造函数 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphoreslim.-ctor?view=netframework-4.8)

SemaphoreSlim有多个重载构造函数，这里只对其中参数最多的一个进行说明：

```csharp
public SemaphoreSlim (int initialCount, int maxCount);
```

- initialCount：初始入口数，指定初始允许多少个线程进入。
- maxCount：最大并发入口数，指定最多允许多少个线程同时处理。

### SemaphoreSlim 的属性

- [CurrentCount](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphoreslim.currentcount?view=netframework-4.8#system-threading-semaphoreslim-currentcount)：获取可以输入 SemaphoreSlim 对象的剩余线程数。

- [AvailableWaitHandle](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphoreslim.availablewaithandle?view=netframework-4.8#system-threading-semaphoreslim-availablewaithandle)：返回一个可用于在信号量上等待的 WaitHandle。

注意：如果使用 SemaphoreSlim(Int32 maxCount) 构造函数来实例化 SemaphoreSlim 对象，获取其 CurrentCount 属性，其值可能会大于 maxCount。 ==编程人员应负责确保调用一个 Wait 或 WaitAsync 方法，便调用一个 Release，常见的做法是通过try..finally语句强制Release。==



### SemaphoreSlim 的方法

和Semaphore中的方法基本类似，具体参见官方文档：[SemaphoreSlim 的方法](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphoreslim?view=netframework-4.8#methods)

与 Semaphore 不同的是，SemaphoreSlim有 Close() 方法，而SemaphoreSlim没有，SemaphoreSlim 不需要 `Close()`。

补充说明：

可以把信号量想成全局计数器，调用wait方法，当前线程将减小1，然后执行受保护的代码段。调用完毕后，release将增加信号量对象的当前计数。调用wait和release不必在一个线程中。

使用using语句只是为了确保semaphoreSlim对象总是被释放，因为它内部使用了非托管资源，避免内存泄漏问题。 



### SemaphoreSlim 实战

推荐的使用方式：

```
SemaphoreSlim.Wait()
try
{
	//处理逻辑
	//也可以将Wait()放到try中，但Release()一定要再finally中
}
finally{
	SemaphoreSlim.Release()
}
```

示例一，将上述的Semaphore示例改为SemaphoreSlim：

```csharp
    class Program
    {
        // 求和
        private static int sum = 0;
        private static SemaphoreSlim _pool;

        // 判断十个线程是否结束了。
        private static int isComplete = 0;
        static void Main(string[] args)
        {
            Console.WriteLine("执行程序");

            // 设置允许最大三个线程进入资源池
            // 一开始设置为0，就是初始化时允许几个线程进入
            // 这里设置为0，后面按下按键时，可以放通三个线程
            _pool = new SemaphoreSlim(0, 3);
            for (int i = 0; i < 10; i++)
            {
                Thread thread = new Thread(new ParameterizedThreadStart(AddOne));
                thread.Start(i + 1);
            }

            Console.WriteLine("任意按下键(不要按关机键)，可以打开资源池");
            Console.ReadKey();
            // 
            _pool.Release(3);

            // 这里没有任何意义，就单纯为了演示查看结果。
            // 等待所有线程完成任务
            while (true)
            {
                if (isComplete >= 10)
                    break;
                Thread.Sleep(TimeSpan.FromSeconds(1));
            }
            Console.WriteLine("sum = " + sum);
            // 释放池
        }

        public static void AddOne(object n)
        {
            Console.WriteLine($"    线程{(int)n}启动，进入队列");
            // 进入队列等待
            _pool.Wait();
            Console.WriteLine($"第{(int)n}个线程进入资源池");
            // 进入资源池
            for (int i = 0; i < 10; i++)
            {
                Interlocked.Add(ref sum, 1);
                Thread.Sleep(TimeSpan.FromMilliseconds(200));
            }
            // 解除占用的资源池
            _pool.Release();
            isComplete += 1;
            Console.WriteLine($"                     第{(int)n}个线程退出资源池");
        }
    }
```



示例二，来自于《C#高级编程》：

```c#
static void TaskMain(SemaphoreSlim semaphore)
{
    bool isCompleted = false;
    while (!isCompleted)
    {
        //锁定信号量，定义最长等待时间为600毫秒
        if (semaphore.Wait(600))
        {
            try
            {
                Console.WriteLine($"Task {Task.CurrentId} locks the semaphore");
                Task.Delay(2000).Wait();
            }
            finally
            {
                Console.WriteLine($"Task {Task.CurrentId} releases the semaphore");
                semaphore.Release();
                isCompleted = true;
            } 
        }
        else{
            Console.WriteLine($"Timeout for task {Task.CurrentId}; wait again");
        }
    }
}

public static void Run()
{
    int taskCount = 6;
    int semaphoreCount = 3;
    //创建计数为3的信号量
    //该构造函数第一个参数表示最初释放的锁定量，第二个参数定义了锁定个数的计数
    var semaphore = new SemaphoreSlim(semaphoreCount, semaphoreCount);
    var tasks = new Task[taskCount];
    for(int i = 0; i < taskCount; i++)
    {
        tasks[i] = Task.Run(()=>TaskMain(semaphore));
    }

    Task.WaitAll(tasks);
    Console.WriteLine("All tasks finished");
}
```

> 上述代码中的`Run()`方法中，创建了6个任务和一个计数为3的信号量。在`SemaphoreSlim`类的构造方法中，第一个参数定义了最初释放的锁定数，第二个参数定义了锁定个数的计数。如果第一个参数的值小于第二个参数，它们的差就是已经分配线程的计数值。与互斥一样，可以给信号量指定名称，使之在不同的进程之间共享。实例中，定义信号量时没有指定名称，所以它只能在这个进程中使用。
>
> 上述代码中的`TaskMain()`方法中，任务利用`Wait()`方法锁定信号量。信号量的计数是3，所以有3个任务可以获得锁定。第4个任务必须等待，这里还定义了最长等待时间为600毫秒。如果在该等待时间过后未能获得锁定，任务就把一条消息写入控制台，在循环中继续等待。只要获得了锁定，任务就把一条消息写入控制台，等待一段时间，然后解除锁定。在解除锁定时，在任何情况下一定要解除资源的锁定，这一点很重要。这就是要在`finally`处理程序中调用`SemaphoreSlim.Release()`方法的原因。

上述代码执行后，输出结果如下：

```
Task 3 locks the semaphore
Task 2 locks the semaphore
Task 1 locks the semaphore
Timeout for task 4; wait again
Timeout for task 4; wait again
Timeout for task 5; wait again
Timeout for task 4; wait again
Task 1 releases the semaphore
Task 9 locks the semaphore
Task 3 releases the semaphore
Task 5 locks the semaphore
Task 2 releases the semaphore
Task 4 locks the semaphore
Task 4 releases the semaphore
Task 5 releases the semaphore
Task 9 releases the semaphore
All tasks finished
-----程序执行完毕-----
```





----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [Semaphore 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphore?view=netframework-4.8)
- [SemaphoreSlim 类 (System.Threading) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.semaphoreslim?view=netframework-4.8)



Last updated：2025-08-31





