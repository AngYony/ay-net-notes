# C# 线程同步——读写锁（ReaderWriterLockSlim）

ReaderWriterLockSlim 属于非排它锁。



当某个资源的读操作很多，但写操作很少，此时可以使用读写锁，来最大限度的保证锁的可用性。

ReaderWriterLockSlim 是在 .NET Fx3.5 中引入的，它替代了笨重的ReaderWriterLock类，ReaderWriterLock 和 ReaderWriterLockSlim 具有相似的功能，但是ReaderWriterLock的执行速度更慢，并且本身存在一些锁升级处理机制的设计缺陷。因此实际使用中，应该采用ReaderWriterLockSlim。

与常规的lock（Monitor.Enter/Exit）相比，ReaderWriterLockSlim的执行速度任然慢很多，但是它可以在==大量的读操作和少量写操作==的环境下减少锁竞争。

ReaderWriterLockSlim 和ReaderWriterLock都拥有两种基本的锁，即读锁和写锁：

- 写锁是全局排它锁
- 读锁可以兼容其他的读锁

因此，==一个持有写锁的线程，将阻塞其他任何视图获取读锁或写锁的线程（反之亦然）。但是，如果没有任何线程持有写锁的话，那么其他任意数量的线程都可以并发获得读锁==。



## ReaderWriterLockSlim类

| 方法                                  | 说明                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| EnterReadLock()                       | 尝试进入读取模式锁定状态。                                   |
| EnterUpgradeableReadLock()            | 尝试进入可升级模式锁定状态。                                 |
| EnterWriteLock()                      | 尝试进入写入模式锁定状态。                                   |
| ExitReadLock()                        | 减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。 |
| ExitUpgradeableReadLock()             | 减少可升级模式的递归计数，并在生成的计数为 0（零）时退出可升级模式。 |
| ExitWriteLock()                       | 减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。 |
| TryEnterReadLock(Int32)               | 尝试进入读取模式锁定状态，可以选择整数超时时间。             |
| TryEnterReadLock(TimeSpan)            | 尝试进入读取模式锁定状态，可以选择超时时间。                 |
| TryEnterUpgradeableReadLock(Int32)    | 尝试进入可升级模式锁定状态，可以选择超时时间。               |
| TryEnterUpgradeableReadLock(TimeSpan) | 尝试进入可升级模式锁定状态，可以选择超时时间。               |
| TryEnterWriteLock(Int32)              | 尝试进入写入模式锁定状态，可以选择超时时间。                 |
| TryEnterWriteLock(TimeSpan)           | 尝试进入写入模式锁定状态，可以选择超时时间。                 |

`EnterReadLock()` / `TryEnterReadLock` 和 `ExitReadLock()` 成对出现。

`EnterWriteLock()` / `TryEnterWriteLock()` 和 `ExitWriteLock()` 成对出现。

`EnterUpgradeableReadLock()` 进入可升级的读模式锁定状态。

`EnterReadLock()` 使用 `EnterUpgradeableReadLock()` 进入升级状态，在恰当时间点 通过 `EnterWriteLock()` 进入写模式。（也可以倒过来）

ReaderWriterLockSlim 的读、写入锁模板如下：

```csharp
private static ReaderWriterLockSlim toolLock = new ReaderWriterLockSlim();

// 读
private T Read()
{
    try
    {
        toolLock.EnterReadLock();           // 获取读取锁
        return obj;
    }
    catch { }
    finally
    {
        toolLock.ExitReadLock();            // 释放读取锁
    }
    return default;
}

// 写
public void Write(int key, int value)
{
    try
    {
        //可升级锁只出现在写操作中，目的是为了在同一个原子操作中将读锁转换为写锁。
        toolLock.EnterUpgradeableReadLock();

        try
        {
            toolLock.EnterWriteLock();
            // 
        }
        catch{}
        finally
        {
            toolLock.ExitWriteLock();
        }
    }
    catch { }
    finally
    {
        toolLock.ExitUpgradeableReadLock();
    }
}
```

注意：可升级锁只出现在写操作中，目的是为了在同一个原子操作中将读锁转换为写锁。

可升级锁和读锁的区别：

虽然可升级锁可以和任意数目的读锁并存，但是一次只能获取一个可升级锁。这可以将锁的升级竞争序列化从而避免在升级中出现死锁。

## ReaderWriterLockSlim 的使用示例

下述示例，来自于《C#7.0 核心技术指南》，三个线程将持续读取列表中的元素，另外两个线程每隔100毫秒生成一个随机数写入到列表中：

```c#
internal class Program
{
    static ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();
    static List<int> _items = new List<int>();
    static Random _rand = new Random();

    static void Read()
    {
        while (true)
        {
            _rw.EnterReadLock();
            foreach (int i in _items) Thread.Sleep(10);
            _rw.ExitReadLock();
        }
    }

    static void Write(object threadID)
    {
        while (true)
        {
            int newNumber = GetRandNum(100);
            //升级锁，实现在一个原子操作中奖读锁转换为写锁
            _rw.EnterUpgradeableReadLock();
            //获取写入锁
            _rw.EnterWriteLock();
            _items.Add(newNumber);
            //释放写入锁
            _rw.ExitWriteLock();
            Console.WriteLine("Thread " + threadID + " added " + newNumber);
            //释放升级锁
            _rw.ExitUpgradeableReadLock();
            Thread.Sleep(100);
        }
    }

    static int GetRandNum(int max) { lock (_rand) return _rand.Next(max); }

    private static void Main(string[] args)
    {
        new Thread(Read).Start();
        new Thread(Read).Start();
        new Thread(Read).Start();

        new Thread(Write).Start("A");
        new Thread(Write).Start("B");
    }
}
```



----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [2. 线程同步 · C# 多线程与异步](https://threads.whuanle.cn/2.thread_sync/)

Last updated：2025-08-31





