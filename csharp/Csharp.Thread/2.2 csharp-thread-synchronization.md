# C# 线程同步

[TOC]

线程安全指的是多个线程访问共享资源时，对共享资源的访问不会导致数据不一致或不可预期的结果。

解决线程安全的常见方式：

- 同步机制：用于协调和控制多个线程之间执行顺序和互斥访问共享资源。确保线程按照特定的顺序执行，避免竞态条件和数据不一致的问题。
- 原子操作：在执行过程中不会被中断的操作。不可分割，要么完全执行，要么完全不执行，没有中间状态。在多线程环境下，原子操作能够保证数据的一致性和可靠性，避免出现竞态条件和数据竞争的问题。C#中用于进行原子操作的主要是Interlocked类型。



如果需要共享数据，就必须使用同步技术，确保一次只有一个线程访问和改变共享状态。如果不注意同步，就会出现争用条件和死锁。

同步（synchronization）是指==协调并发操作，得到可以预测的结果的行为==，主要用于多个线程访问同一个数据时的操作。

==如果有 N 个线程都会执行某个操作，当一个线程正在执行这个操作时，其它线程都必须依次等待，这就是线程同步。==

最简单的也是最实用的同步做法是使用任务延续（continuation）和任务组合器。延续和任务组合器将并发程序构造为异步操作，减少了对锁和信号发送的依赖。具体参考任务章节。

本文是对底层的同步结构的进行介绍。

同步结构可以分为三类：

- 排他锁：排他锁每一次只允许一个线程执行特定的活动或一段代码。它的主要目的是令线程访问共享的写状态而不互相影响。排他锁包括lock、Mutex和SpinLock。
- 非排他锁：非排他锁实现了有限的并发性。非排他锁包括Semaphore（Slim）和 ReaderWriterLock（Slim）。
- 信号发送结构：这种结构允许线程在接到一个或者多个其他线程的通知之前保持阻塞状态。信号发送结构包括ManualResetEvent（Slim）、AutoResetEvent、CountdownEvent和Barrier。前三者就是所谓的事件等待句柄（event waithandle）。

除此之外，一些结构在不使用锁的前提下也可以巧妙地处理特定的共享状态的同步操作，称为非阻塞同步结构（nonblocking synchronization construct）。它们包括Thread.MemoryBarrier、Thread.VolatileRead、Thread.VolatileWrite、volatile关键字和Interlocked类。



## 多线程竞争下的原子操作

### 竞争条件

当两个或两个以上的线程访问共享数据，并且尝试同时改变它时，就会发生争用的情况。它们所依赖的那部分共享数据，叫做竞争条件。

数据争用是竞争条件中的一种，出现竞争条件可能会导致内存(数据)损坏或者出现不确定性的行为。

### 线程同步

如果有 N 个线程都会执行某个操作，当一个线程正在执行这个操作时，其它线程都必须依次等待，这就是线程同步。

多线程环境下出现竞争条件，通常是没有执行正确的同步而导致的。

### CPU时间片和上下文切换

**时间片（timeslice）**是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。

> 首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间 片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。

**上下文切换（Context Switch）**，也称做进程切换或任务切换，是指 CPU 从一个进程或线程切换到另一个进程或线程。

> 在接受到中断（Interrupt）的时候，CPU 必须要进行上下文交换。进行上下文切换时，会带来性能损失。

### 阻塞

阻塞状态指==线程处于等待状态==。当线程处于阻塞状态时，会尽可能少占用 CPU 时间。

当线程从运行状态(Runing)变为阻塞状态时(WaitSleepJoin)，操作系统就会将此线程占用的 CPU 时间片分配给别的线程。当线程恢复运行状态时(Runing)，操作系统会重新分配 CPU 时间片。

分配 CPU 时间片时，会出现上下文切换。

### 内核模式和用户模式

只有操作系统才能切换线程、挂起线程，因此阻塞线程是由操作系统处理的，这种方式被称为内核模式(kernel-mode)。

`Sleep()`、`Join()` 等，都是使用内核模式来阻塞线程，实现线程同步(等待)。

==内核模式实现线程等待时，出现上下文切换。这适合等待时间比较长的操作，这样会减少大量的 CPU 时间损耗。==

如果线程只需要等待非常微小的时间，阻塞线程带来的上下文切换代价会比较大，这时我们可以使用**自旋**，来实现线程同步，这一方法称为用户模式(user-mode)。

### 死锁

锁定并不是越多越好，过多的锁定会造成死锁，在死锁中，至少有两个线程被挂起，并等待对象解除锁定。由于两个线程都在等待对方，就出现了死锁，线程将无限等待下去。

### Interlocked 类

对于常用的`i++`这种运算，在多线程中，它并不是线程安全的，它的操作包括从内存中获取一个值，给该值递增`1`，再将它存储回内存中。这些操作都可能被线程调度器打断。`Interlocked`类提供了以线程安全的方式递增、递减、交换和读取值的方法。

在使用`lock`语句对类似`i++`这种操作进行锁同步时，使用`Interlocked`类会快的多。但是，它只能用于简单的同步问题。

Interlocked 为多个线程共享的变量（简单值类型）提供原子操作。

使用 Interlocked 类 避免竞争条件，可以在不阻塞线程(lock、Monitor)的情况下，对目标对象做修改。

Interlocked 类是静态类，让我们先来看看 Interlocked 的常用方法：

| 方法                  | 作用                                                         |
| --------------------- | ------------------------------------------------------------ |
| ==CompareExchange()== | 比较两个数是否相等，如果相等，则替换第一个值。               |
| Decrement()           | 以原子操作的形式递减指定变量的值并存储结果。                 |
| Exchange()            | 以原子操作的形式，设置为指定的值并返回原始值。               |
| Increment()           | 以原子操作的形式递增指定变量的值并存储结果。                 |
| Add()                 | 对两个数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。 |
| Read()                | 返回一个以原子操作形式加载的值。                             |

C# 中赋值和一些简单的数学运算不是原子操作，受多线程环境影响，可能会出现问题。

错误示例：

```csharp
static void Main(string[] args)
{
    for (int i = 0; i < 5; i++)
    {
        Thread thread = new Thread(AddOne);
        thread.Start();
    }

    Thread.Sleep(TimeSpan.FromSeconds(2));
    Console.WriteLine("sum = " + sum);
}
```

运行上述代码，每次运行的结果都不一样。这是因为多个线程使用同一个变量进行操作时，并不知道此变量已经在其它线程中发生改变，导致执行完毕后结果不符合期望。

操作值类型时，其内存位置的值会被复制到 CPU 缓存中，例如 CPU1 将 sum 值复制到 L2 中，CPU1 还没有将计算后的结果放到 L3， CPU2 读取了一个旧值，即 CPU2 发生脏读，此时 CPU1、CPU2 操作的 `int sum` 导致数据混乱。

![image-20220327152524746](./assets/image-20220327152524746.png)

因此，这里就需要原子操作，==在某个时刻，必须只有一个线程能够进行某个操作==。而上面的操作，指的是读取、计算、写入这一过程。

当然，我们==可以使用 lock 或者 Monitor 来解决，但是这样会带来比较大的性能损失==。这时 Interlocked 就起作用了，对于一些简单的操作运算， Interlocked 可以实现原子性的操作。

#### Interlocked.Increment()、Interlocked.Decrement()

`Interlocked.Increment()` 是递增，而 `Interlocked.Decrement()` 是递减。

```csharp
public static void AddOne()
{
    for (int i = 0; i < 100_0000; i++)
    {
        Interlocked.Increment(ref sum);
    }
}
```

#### Interlocked.Exchange()

`Interlocked.Exchange()` 实现赋值运算。这个方法有多个重载，我们找其中一个来看看：

```csharp
public static int Exchange(ref int location1, int value);
```

意思是将 value 赋给 location1 ，然后返回 location1 改变之前的值。

```csharp
static void Main(string[] args)
{
    int a = 1;
    int b = 5;

    // a 改变前为1
    int result1 = Interlocked.Exchange(ref a, 2);

    Console.WriteLine($"a新的值 a = {a}   |  a改变前的值 result1 = {result1}");

    Console.WriteLine();

    // a 改变前为 2，b 为 5
    int result2 = Interlocked.Exchange(ref a, b);

    Console.WriteLine($"a新的值 a = {a}   | b不会变化的  b = {b}   |   a 之前的值  result2 = {result2}");
}
```

#### Interlocked.CompareExchange()

其中一个重载：

```csharp
public static int CompareExchange (ref int location1, int value, int comparand)
```

比较两个 32 位有符号整数是否相等，如果相等，则替换第一个值。

如果 `comparand` 和 `location1` 中的值相等，则将 `value` 存储在 `location1`中。 否则，不会执行任何操作。

==看准了，是 `location1` 和 `comparand` 比较！==

示例一，使用`lock`语句锁定对某个变量的访问，对该变量进行比较操作：

```c#
lock (obj)
{
    if (someState == null)
    {
        someState = newState;
    }
}
```

上述可以使用`Interlocked.CompareExchange()`方法进行改写，并且执行的更快：

```c#
Interlocked.CompareExchange(ref someState, newState, null);
```

示例二：

```csharp
 static void Main(string[] args)
{
    int location1 = 1;
    int value = 2;
    int comparand = 3;

    Console.WriteLine("运行前：");
    Console.WriteLine($" location1 = {location1}    |   value = {value} |   comparand = {comparand}");

    Console.WriteLine("当 location1 != comparand 时");
    int result = Interlocked.CompareExchange(ref location1, value, comparand);
    Console.WriteLine($" location1 = {location1} | value = {value} |  comparand = {comparand} |  location1 改变前的值  {result}");

    Console.WriteLine("当 location1 == comparand 时");
    comparand = 1;
    result = Interlocked.CompareExchange(ref location1, value, comparand);
    Console.WriteLine($" location1 = {location1} | value = {value} |  comparand = {comparand} |  location1 改变前的值  {result}");
}
```

#### Interlocked.Add()

对两个 32 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。

```csharp
public static int Add (ref int location1, int value);
```

只能对 int 或 long 有效。

回到第一小节的多线程求和问题，使用 `Interlocked.Add()` 来替换`Interlocked.Increment()`。

```csharp
static void Main(string[] args)
{
    for (int i = 0; i < 5; i++)
    {
        Thread thread = new Thread(AddOne);
        thread.Start();
    }

    Thread.Sleep(TimeSpan.FromSeconds(10));
    Console.WriteLine("sum = " + sum);
}
private static int sum = 0;
public static void AddOne()
{
    for (int i = 0; i < 100_0000; i++)
    {
        Interlocked.Add(ref sum,1);
    }
}
```

#### Interlocked.Read()

返回一个以原子操作形式加载的 64 位值。

64位系统上不需要 Read 方法，因为64位读取操作已是原子操作。 在32位系统上，64位读取操作不是原子操作，除非使用 Read 执行。

```csharp
public static long Read (ref long location);
```

就是说 32 位系统上才用得上。具体场景我没有找到。



### volatile 关键字

这里直接引用官方文档的解释：

`volatile` 关键字指示一个字段可以由多个同时执行的线程修改。 出于性能原因，编译器，运行时系统甚至硬件都可能重新排列对存储器位置的读取和写入。即禁用缓存值，被修饰的变量的值在每个引用的线程都保持可见性，保证拿到的都是

据官方文档，`volatile` 关键字可应用于以下类型的字段：

- 引用类型。
- 指针类型（在不安全的上下文中）。 请注意，虽然指针本身可以是可变的，但是它指向的对象不能是可变的。 换句话说，不能声明“指向可变对象的指针”。
- 简单类型，如 `sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`char`、`float` 和 `bool`。
- 具有以下基本类型之一的 `enum` 类型：`byte`、`sbyte`、`short`、`ushort`、`int` 或 `uint`。
- 已知为引用类型的泛型类型参数。
- IntPtr 和 UIntPtr。

注意，volatile 只能用于引用类型或等于小于 32 位的值类型。

![image-20220731102225174](./assets/image-20220731102225174.png)

.NET 设计上是支持 32 位系统和 64 位系统的，而 long 类型固定是 64 位，在 32 位的系统下，CPU 寄存器执行指令时，寄存器一次只能处理 4 字节，要处理 long 类型，取内存就需要两次指令，高 4 字节和 低 4 字节是分开计算的，因此无法保证 long 的原子性。另外，在 32 位系统下，需要额外使用其它指令配合计算 long ，因此也会消耗一部分性能。

最简单的例子就是学 C 语言时，都会学到的结构体对齐。

奇怪，既然 long 、double 不行，为啥引用类型可以？

因为 `private volatile object obj;` 保存的是对象的引用地址，其地址长度跟 CPU 有关，取地址值时，只需要一次取数据指令即可。

关于 volatile 的使用方法有几个误区，第一个误区是，==volatile 不能保证数据隔离==。

踩坑代码：

```c#
private static volatile int sum = 0;
////单独执行一次，sum值为1000000
static void AddOne()
{
    for (int i = 0; i < 100_0000; i++)
    {
        sum += 1;
    }
}
static void Main(string[] args)
{
    for (int i = 0; i < 5; i++)
    {
        new Thread(AddOne).Start();
    }
    Thread.Sleep(TimeSpan.FromSeconds(10));
    Console.WriteLine("sum = " + sum);
    Console.ReadKey();
}
```

上述代码中，每调用一次AddOne()方法，sum的值都加1000000，因此启动了5个线程，期望的结果应该是5000000才对，而代码实际运行结果为，并且每次执行的结果都不一样：

```
sum = 1398807
```

原因在于：volatile 可以保证同一个字段被多个线程修改时，修改后的最新值能够被线程看到，避免发生脏读，**它无法解决多个线程同时写的问题**。==因此，千万不要简单的以为使用了volatile，就可以代替锁操作。==volatile的主要作用是：**解决多线程情况下，==一==写多读得情况。**



## Locker 和 Monitor 锁（排它锁）

### lock 关键字

lock 是 Monitor 实现的语法糖。生成的代码对比：

```c#
lock (x)
{
    // Your code...
}
```

```c#
object __lockObj = x;
bool __lockWasTaken = false;
try
{
    System.Threading.Monitor.Enter(__lockObj, ref __lockWasTaken);
    // Your code...
}
finally
{
    if (__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);
}
```

lock 用于对一个引用类型（因为值类型只是锁定了一个副本，并没有任何意义）进行加锁，同一时刻内只有一个线程能够访问此对象。

当锁定了一个线程后，就可以运行`lock`语句块。在`lock`语句块结束时，对象的锁定被解除，另一个等待锁定的线程就可以获得该锁定块了。

使用`lock`语句，如果要锁定静态成员，可以把锁放在`object`类型或静态成员上；

如果要将类的实例成员设置为线程安全的（一次只能有一个线程访问相同实例的成员），可以在类中单独定义一个`object`类型的成员对象，在该类的其他成员只用将这个对象用于`lock`语句。

lock 示例代码：

```csharp
class Program
{
    private static object obj = new object();
    private static int sum = 0;
    static void Main(string[] args)
    {
        Thread thread1 = new Thread(Sum1);
        thread1.Start();
        Thread thread2 = new Thread(Sum2);
        thread2.Start();
        while (true)
        {
            Console.WriteLine($"{DateTime.Now.ToString()}:" + sum);
            Thread.Sleep(TimeSpan.FromSeconds(1));
        }
    }

    public static void Sum1()
    {
        sum = 0;
        lock (obj)
        {
            for (int i = 0; i < 10; i++)
            {
                sum += i;
                Console.WriteLine("Sum1");
                Thread.Sleep(TimeSpan.FromSeconds(2));
            }
        }
    }

    public static void Sum2()
    {
        sum = 0;
        lock (obj)
        {
            for (int i = 0; i < 10; i++)
            {
                sum += 1;
                Console.WriteLine("Sum2");
                Thread.Sleep(TimeSpan.FromSeconds(2));
            }
        }
    }
}
```

也可以将类自己设置为锁， 这可以防止恶意代码对公共对象采用做锁。

例如：

```csharp
  public void Access()
    {
        lock(this) {}
     }
```

注意：

- 锁可以阻止其它线程执行锁块(lock(o){})中的代码，当锁定时，其它线程必须等待锁中的线程执行完成并释放锁。但是这可能会给程序带来性能影响。
- 锁不太适合I/O场景，例如文件I/O，繁杂的计算或者操作比较持久的过程，会给程序带来很大的性能损失。



### Monitor 类

与C#的`lock`语句相比，`Monitor`类的主要优点是：可以添加一个等待被锁定的超时值。这样其他线程就不会无限期地等待被锁定。可以使用`Monitor.TryEnter()`方法，并为该方法传递一个超时值，指定等待被锁定的最长时间。

```
bool _lockTaken = false;
Monitor.TryEnter(_obj, 500, ref _lockTaken);
if (_lockTaken)
{
    try
    {

    }
    finally
    {
        Monitor.Exit(_obj);
    }
}
else
{
    //didn't get the lock,do something else
}
```

> 上述中，如果`obj`被锁定，`TryEnter()`方法就把布尔型的引用参数设置为`true`，并同步的访问由对象`obj`锁定的状态。如果另个一线程锁定`obj`的时间超过了500毫秒，`TryEnter()`方法就把变量`lockTaken`设置为`false`，线程不在等待，而是用于执行其他操作。也许在以后，该线程会尝试再次获得锁定。

| 操作             | 说明                                                         |
| :--------------- | :----------------------------------------------------------- |
| Enter， TryEnter | 获取对象的锁。 此操作还标记关键节的开头。 其他任何线程都不能输入临界区，除非它使用不同的锁定对象执行临界区中的说明。 |
| Wait             | 释放对象的锁，以允许其他线程锁定并访问对象。 调用线程会等待另一个线程访问对象。 使用脉冲信号通知等待线程关于对象状态的更改。 |
| Pulse 、PulseAll | 将信号发送到一个或多个等待线程。 信号通知等待线程：锁定对象的状态已更改，锁的所有者已准备好释放该锁。 正在等待的线程置于对象的就绪队列中，因此它可能最终接收对象的锁。 线程锁定后，它可以检查对象的新状态，以查看是否已达到所需的状态。 |
| Exit             | 释放对象的锁。 此操作还标记受锁定对象保护的临界区的结尾。    |

示例一：

```csharp
private static object obj = new object();
private static bool acquiredLock = false;

public static void Test()
{
    try
    {
        Monitor.Enter(obj, ref acquiredLock);
    }
    catch { }
    finally
    {
        if (acquiredLock)
            Monitor.Exit(obj);
    }
}
```

`Monitor.Enter` 锁定 obj 这个对象，并且设置 acquiredLock 为 true，告诉别人 obj 已经被锁定。最后结束时，判断 acquiredLock ，释放锁，并设置 acquiredLock 为 false。

临界区：指被某些符号包围的范围。例如 `{}` 内。

Monitor 对象的 Enter 和 Exit 方法来标记临界区的开头和结尾。

`Enter()` 方法获取锁后，能够保证只有单个线程能够使用临界区中的代码。使用 Monitor 类，最好搭配 `try{...}catch{...}finally{...}` 来使用，因为如果获取到锁但是没有释放锁的话，会导致其它线程无限阻塞，即发生死锁。

一般来说，lock 关键字够用了。

下面示范了多个线程如何使用 Monitor 来实现锁：

```csharp
private static object obj = new object();
private static bool acquiredLock = false;
static void Main(string[] args)
{
    new Thread(Test1).Start();
    Thread.Sleep(1000);
    new Thread(Test2).Start();
}

public static void Test1()
{
    try
    {
        Monitor.Enter(obj, ref acquiredLock);
        for (int i = 0; i < 10; i++)
        {
            Console.WriteLine("Test1正在锁定资源");
            Thread.Sleep(1000);
        }
    }
    catch { }
    finally
    {
        if (acquiredLock)
            Monitor.Exit(obj);
        Console.WriteLine("Test1已经释放资源");
    }
}
public static void Test2()
{
    bool isGetLock = false;
    isGetLock = Monitor.TryEnter(obj, 500);
    if (isGetLock == false)
    {
        Console.WriteLine("锁还没有释放，我不干活了");
        return;
    }
    try
    {
        Monitor.Enter(obj, ref acquiredLock);
        for (int i = 0; i < 10; i++)
        {
            Console.WriteLine("Test2正在锁定资源");
            Thread.Sleep(1000);
        }
    }
    catch { }
    finally
    {
        if (acquiredLock)
            Monitor.Exit(obj);
        Console.WriteLine("Test2已经释放资源");
    }
}
```

如果对象已经被锁定，另一个线程使用 `Monitor.Enter` 对象，就会一直等待另一个线程解除锁定。可以通过 `Monitor.TryEnter()` 来设置等待时间，超过一段时间后，如果锁还没有释放，就会返回 false。



## 方法锁

`[MethodImpl(MethodImplOptions.Synchronized)]` 特性标记，可以让该方法只允许同时一个线程运行。

```csharp
[MethodImpl(MethodImplOptions.Synchronized)]
public void Test()
{

}
```



## 进程互斥锁：Mutex 锁（排它锁）

Mutex 中文为互斥，Mutex 类叫做互斥锁。Mutex 跟 lock 相似，但是 Mutex 支持多个进程，Mutex 大约比 lock 慢 20 倍。

`Mutex`（mutual exclusion，互斥）是.NET Framework中提供跨多个进程同步访问的一类。它非常类似于`Monitor`类，因为它们都只有一个线程能拥有锁定。只有一个线程能获得互斥锁定，访问受互斥保护的同步代码区域。

互斥锁(Mutex)，用于多线程中防止两条线程同时对一个公共资源进行读写的机制，Mutex 只能在获得锁的线程中释放锁。

Mutex 只用于实现进程间的同步，它会耗费比较多的资源，进程内请考虑 Monitor/lock。

Mutex 的工作原理：

当两个或两个以上的线程同时访问共享资源时，操作系统需要一个同步机制来确保每次只有一个线程使用资源。

> Mutex 是一种同步基元，Mutex 仅向一个线程授予独占访问共享资源的权限。这个权限依据就是 互斥体，当一个线程获取到互斥体后，其它线程也在试图获取互斥体时，就会被挂起(阻塞)，直到第一个线程释放互斥体。

Windows 操作系统中，Mutex 同步对象有两个状态：

- signaled：未被任何对象拥有；
- nonsignaled：被一个线程拥有；

### Mutex类

Mutex 类其构造函数如下：

| 构造函数                        | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| Mutex()                         | 使用默认属性初始化 Mutex类的新实例。                         |
| Mutex(Boolean)                  | 使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权）初始化 Mutex 类的新实例。 |
| Mutex(Boolean, String)          | 使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称）初始化 Mutex 类的新实例。 |
| Mutex(Boolean, String, Boolean) | 使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权的 Boolean 值初始化 Mutex 类的新实例。 |

Mutex 构造函数中的 String类型参数 叫做互斥量，而互斥量是全局的操作系统对象。

构造函数中，如果为 `name` 指定 `null` 或空字符串，则将创建一个本地 Mutex 对象，只会在进程内有效。

以下述构造函数为例：

```
public Mutex (bool initiallyOwned, string name, out bool createdNew);
```

通过 new 来实例化 Mutex 类，会检查系统中此互斥量 name 是否已经被使用，如果没有被使用，则会创建 name 互斥量并且此线程拥有此互斥量的使用权；此时 `createdNew == true`。

那么 initiallyOwned ，它的作用是是否允许线程是否能够获取到此互斥量的初始化所有权。因为我们希望只有一个程序能够在后台运行，因此我们要设置为 false。

第3个参数定义为输出参数，接收一个表示互斥是否为新建的布尔值。如果返回值为`false`，就表示互斥已经定义。互斥可以在另一个进程中定义，因为操作系统能够识别有名称的互斥，它由不同的进程共享。如果没有给互斥指定名称，互斥就是为命名的，不在不同的进程之间共享。

==Mutex 的 参数中，name 是非常有讲究的==。

在运行终端服务的服务器上，命名系统 mutex 可以有两个级别的可见性。

- 如果其名称以前缀 "Global\" 开头，则 mutex 在所有终端服务器会话中可见。
- 如果其名称以前缀 "Local\" 开头，则 mutex 仅在创建它的终端服务器会话中可见。 在这种情况下，可以在服务器上的其他每个终端服务器会话中存在具有相同名称的单独 mutex。

如果在创建已命名的 mutex 时未指定前缀，则采用前缀 "Local\"。 在终端服务器会话中，两个互斥体的名称只是它们的前缀不同，它们都是对终端服务器会话中的所有进程都可见。

也就是说，前缀名称 "Global\" 和 "Local\" 描述互斥体名称相对于终端服务器会话的作用域，而不是相对于进程。

请参考：

https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.mutex?view=netcore-3.1#methods

https://www.cnblogs.com/suntp/p/8258488.html

Mutex 的常用方法如下：

| 方法                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| Close()                        | 释放由当前 WaitHandle 占用的所有资源。                       |
| Dispose()                      | 释放由 WaitHandle 类的当前实例占用的所有资源。               |
| OpenExisting(String)           | 打开指定的已命名的互斥体（如果已经存在）。                   |
| ReleaseMutex()                 | 释放 Mutex一次。                                             |
| TryOpenExisting(String, Mutex) | 打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。 |
| WaitOne()                      | 阻止当前线程，直到当前 WaitHandle 收到信号。                 |
| WaitOne(Int32)                 | 阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。 |
| WaitOne(Int32, Boolean)        | 阻止当前线程，直到当前的 WaitHandle 收到信号为止，同时使用 32 位带符号整数指定时间间隔，并指定是否在等待之前退出同步域。 |
| WaitOne(TimeSpan)              | 阻止当前线程，直到当前实例收到信号，同时使用 TimeSpan 指定时间间隔。 |
| WaitOne(TimeSpan, Boolean)     | 阻止当前线程，直到当前实例收到信号为止，同时使用 TimeSpan 指定时间间隔，并指定是否在等待之前退出同步域。 |

### Mutex 使用示例

#### 系统只能运行一个程序的实例

示例一，用于控制系统只能运行一个此程序的实例，不允许同时启动多次。

```csharp
class Program
{
    // 第一个程序
    const string name = "www.whuanle.cn";
    private static Mutex m;
    static void Main(string[] args)
    {
        // 本程序是否是 Mutex 的拥有者
        bool firstInstance;
        m = new Mutex(false,name,out firstInstance);
        if (!firstInstance)
        {
            Console.WriteLine("程序已在运行！按下回车键退出！");
            Console.ReadKey();
            return;
        }
        Console.WriteLine("程序已经启动");
        Console.WriteLine("按下回车键退出运行");
        Console.ReadKey();
        m.ReleaseMutex();
        m.Close();
        return;
    }
}
```

运行结果：

![img](./assets/Mutex1.gif)

#### 接替运行

示例二，当同时点击一个程序时，只能有一个实例A可以运行，其它实例进入等待队列，等待A运行完毕后，然后继续运行队列中的下一个实例。

我们将每个程序比作一个人，模拟一个厕所坑位，每次只能有一个人上厕所，其他人需要排队等候。

使用 `WaitOne()` 方法来等待别的进程释放互斥量，即模拟排队；`ReleaseMutex()` 方法解除对坑位的占用。

```csharp
class Program
{
    // 第一个程序
    const string name = "www.whuanle.cn";
    private static Mutex m;
    static void Main(string[] args)
    {
        // wc 还有没有位置
        bool firstInstance;
        m = new Mutex(true,name,out firstInstance);

        // 已经有人在上wc
        if (!firstInstance)
        {
            // 等待运行的实例退出，此进程才能运行。
            Console.WriteLine("排队等待");
            m.WaitOne();
            GoWC();
            return;
        }
        GoWC();

        return;
    }

    private static void GoWC()
    {
        Console.WriteLine(" 开始上wc");
        Thread.Sleep(1000);
        Console.WriteLine(" 开门");
        Thread.Sleep(1000);
        Console.WriteLine(" 关门");
        Thread.Sleep(1000);
        Console.WriteLine(" xxx");
        Thread.Sleep(1000);
        Console.WriteLine(" 开门");
        Thread.Sleep(1000);
        Console.WriteLine(" 离开wc");
        m.ReleaseMutex();
        Thread.Sleep(1000);
        Console.WriteLine(" 洗手");
    }
}
```

运行效果：

![img](./assets/Mutex2.gif)

上述示例中的下述代码：

```
m = new Mutex(true,name,out firstInstance);
```

一个程序结束后，要允许其它线程能够创建 Mutex 对象获取互斥量，需要将构造函数的第一个参数设置为 true。

你也可以改成 false，看看会报什么异常。

你可以使用 `WaitOne(Int32)` 来设置等待时间，单位是毫秒，超过这个时间就不排队了，去别的地方上厕所。

为了避免出现问题，请考虑在 finally 块中执行 `m.ReleaseMutex()`。

#### 进程同步示例

示例三，父进程 Parent 启动子进程 Children ，等待子进程 Children 执行完毕，子进程退出，父进程退出。

新建一个 .NET Core 控制台项目，名称为 Children，其 Progarm 中的代码如下：

```csharp
using System;
using System.Threading;

namespace Children
{
    class Program
    {
        const string name = "进程同步示例";
        private static Mutex m;
        static void Main(string[] args)
        {
            Console.WriteLine("子进程被启动...");
            bool firstInstance;

            // 子进程创建互斥体
            m = new Mutex(true, name, out firstInstance);

            // 按照我们设计的程序，创建一定是成功的
            if (firstInstance)
            {
                Console.WriteLine("子线程执行任务");
                DoWork();
                Console.WriteLine("子线程任务完成");

                // 释放互斥体
                m.ReleaseMutex();
                // 结束程序
                return;
            }
            else
            {
                Console.WriteLine("莫名其妙的异常，直接退出");
            }
        }
        private static void DoWork()
        {
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine("子线程工作中");
                Thread.Sleep(TimeSpan.FromSeconds(1));
            }
        }
    }
}
```

然后发布或生成项目，打开程序文件位置，复制线程文件路径。 创建一个新项目，名为 Parent 的 .NET Core 控制台，其 Program 中的代码如下：

```csharp
using System;
using System.Diagnostics;
using System.Threading;

namespace Parent
{
    class Program
    {
        const string name = "进程同步示例";
        private static Mutex m;
        static void Main(string[] args)
        {
            // 晚一些再执行，我录屏要对正窗口位置
            Thread.Sleep(TimeSpan.FromSeconds(3));
            Console.WriteLine("父进程启动！");

            new Thread(() =>
            {
                // 启动子进程
                Process process = new Process();
                process.StartInfo.UseShellExecute = true;
                process.StartInfo.CreateNoWindow = false;
                process.StartInfo.WorkingDirectory = @"../../../ConsoleApp9\Children\bin\Debug\netcoreapp3.1";
                process.StartInfo.FileName = @"../../../ConsoleApp9\Children\bin\Debug\netcoreapp3.1\Children.exe";
                process.Start();
                process.WaitForExit();
            }).Start();


            // 子进程启动需要一点时间
            Thread.Sleep(TimeSpan.FromSeconds(1));

            // 获取互斥体
            bool firstInstance;
            m = new Mutex(true, name, out firstInstance);

            // 说明子进程还在运行
            if (!firstInstance)
            {
                // 等待子进程运行结束
                Console.WriteLine("等待子进程运行结束");
                m.WaitOne();
                Console.WriteLine("子进程运行结束，程序将在3秒后自动退出");
                m.ReleaseMutex();
                Thread.Sleep(TimeSpan.FromSeconds(3));
                return;
            }
        }
    }
}
```

请将 Children 项目的程序文件路径，替换到 Parent 项目启动子进程的那部分字符串中。

然后启动 Parent.exe，可以观察到如下图的运行过程：

![进程同步](./assets/进程同步.gif)



## 自旋（SpinWait）与自旋锁（SpinLock，排它锁）

线程阻塞是会耗费上下文切换的，对于过短的线程等待，这种切换的代价会比较昂贵的。在我们前面的示例中，大量使用了 `Thread.Sleep()` 和各种类型的等待方法，这其实是不合理的。

SpinWait 则提供了更好的选择。

自旋和阻塞的区别自旋与阻塞有一些细微的差别。首先，非常短暂的自旋在条件可以很快得到满足的场景（例如几微秒）下是非常高效的，因为它避免了上下文切换带来的延迟和开销。

三种常用的线程等待：

- `Thread.Sleep();` 会阻塞线程，使得线程交出时间片，然后处于休眠状态，直至被重新唤醒；适合用于长时间的等待；
- `Thread.SpinWait();` 使用了自旋等待，等待过程中会进行一些的运算，线程不会休眠，用于微小的时间等待；长时间等待会影响性能；
- `Task.Delay();` 用于异步中的等待，异步的文章后面才写，这里先不理会；

线程等待有内核模式(Kernel Mode)和用户模式(User Model)。

因为只有操作系统才能控制线程的生命周期，因此使用 `Thread.Sleep()` 等方式阻塞线程，发生上下文切换，此种等待称为内核模式。

用户模式使线程等待，并不需要线程切换上下文，而是**让线程通过执行一些无意义的运算，实现等待，也称为自旋**。自旋的意思是，没事找事做。

自旋一次消耗的时间极低，并且 `Thread.Sleep` 会出现上下文切换，而 `Thread.SpinWait` 不会。`Thread.SpinWait` 适合等待短暂的任务，实现线程同步。

`Thread.SpinWait()` 在极少数情况下，避免线程使用上下文切换很有用。

### SpinWait 

SpinWait 是结构体；Thread.SpinWait() 的原理就是 SpinWait 。

属性：

| 属性              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| Count             | 获取已对此实例调用 SpinOnce() 的次数。                       |
| NextSpinWillYield | 获取对 SpinOnce() 的下一次调用是否将产生处理器，同时触发强制上下文切换。 |

方法：

| 方法                      | 说明                                                     |
| ------------------------- | -------------------------------------------------------- |
| Reset()                   | 重置自旋计数器。                                         |
| SpinOnce()                | 执行单一自旋。                                           |
| SpinOnce(Int32)           | 执行单一自旋，并在达到最小旋转计数后调用 Sleep(Int32) 。 |
| SpinUntil(Func)           | 在指定条件得到满足之前自旋。                             |
| SpinUntil(Func, Int32)    | 在指定条件得到满足或指定超时过期之前自旋。               |
| SpinUntil(Func, TimeSpan) | 在指定条件得到满足或指定超时过期之前自旋。               |

`Thread.Sleep()` 会发生上下文切换，出现比较大的性能损失，如果需要等待的时间很短，那就最好使用 `Thread.SpinWait`，让线程继续占用短时间的 CPU 什么也不做，避免出现线程上下文切换。

SpinWait 实质上是（处理器）使用了非常紧密的循环，并使用 `iterations` 参数指定的循环计数。 SpinWait 等待时间取决于处理器的速度。

SpinWait 无法使你准确控制等待时间，主要是使用一些锁时用到，例如 Monitor.Enter。

### SpinLock

微软文档：提供一个相互排斥锁基元，在该基元中，尝试获取锁的线程将在重复检查的循环中等待，直至该锁变为可用为止。

SpinLock 称为自旋锁，适合用在频繁争用而且等待时间较短的场景。主要特征是避免了阻塞，不出现昂贵的上下文切换。

读写锁 ReaderWriterLock 和 ReaderWriterLockSlim ，而 ReaderWriterLockSlim 内部依赖于 SpinLock，并且比 ReaderWriterLock 快了三倍。

`SpinLock`结构的用法非常类似于`Monitor`类。使用`Enter()`或`TryEnter()`方法获得锁，使用`Exit()`方法释放锁定。与`Monitor`相比，如果基于对象的锁定对象（使用`Monitor`）的系统开销由于垃圾回收而过高，就可以使用`SpinLock`结构。如果有大量的锁定，且锁定的时间总是非常短，`SpinLock`结构就很有用。~~应避免使用多个`SpinLock`结构，也不要调用任何可能阻塞的内容。~~

`SpinLock`结构还提供了属性`IsHeld`和`IsHeldByCurrentThread`，指定它当前是否被锁定。

注意：由于`SpinLock`定义为结构，因此传递`SpinLock`实例时，是按照值类型传递的。

SpinLock 的模板如下：

```csharp
private static void DoWork()
{
    SpinLock spinLock = new SpinLock();
    bool isGetLock = false;     // 是否已获得了锁
    try
    {
        spinLock.Enter(ref isGetLock);
        // 运算
    }
    finally
    {
        if (isGetLock)
            spinLock.Exit();
    }
}
```

需要注意的是， SpinLock 实例不能共享，也不能重复使用。

### 自旋与休眠

当线程处于进入休眠状态或解除休眠状态时，会发生上下文切换，这就带来了昂贵的消耗。

而线程不断运行，就会消耗 CPU 时间，占用 CPU 资源。

对于过短的等待，应该使用自旋(spin)方法，避免发生上下文切换；过长的等待应该使线程休眠，避免占用大量 CPU 时间。

我们可以使用最为熟知的 `Sleep()` 方法休眠线程。有很多同步线程的类型，也使用了休眠手段等待线程（已经写好草稿啦）。

自旋的意思是，没事找事做。



## 信号量（Semaphore，非排它锁）

使用`Semaphore`，可以定义允许同时访问资源的线程个数。如果需要限制可以访问可用资源的线程数，`Semaphore`就很有用。

Semaphore类似于俱乐部：它有特定的容量（允许同时访问的线程数），允许人进入之后锁定席位（Wait方法），一旦满员之后，就不允许其他人（其他线程）进入了，只能在外面排队。每当有人离开时（Release方法），才准许另外一个人进入。

信号量有两个功能相似的实现：Semaphore 和 SemaphoreSlim。两者都可以限制同时访问某一资源或资源池的线程数，实现并发时限制具体数量的线程进行并发操作。

SemaphoreSlim 表示对可同时访问资源或资源池的线程数加以限制的 Semaphore 的轻量替代。SemaphoreSlim是在 .NET Fx4.0 引入的，它进行了一些优化以适应并行编程对低延迟的需求。

SemaphoreSlim的限制：SemaphoreSlim 不使用信号量，不支持进程间同步，只能在进程内使用。SemaphoreSlim不能用于进程间通信。

与 lock 不同的时，Semaphore 允许多个线程同时执行相同的区域代码，因此称为非排他锁。

### 信号量

信号量分为两种类型：本地信号量和命名系统信号量。

- 命名系统信号量在整个操作系统中均可见，可用于同步进程的活动。
- 局部信号量仅存在于进程内。

当 name 为 null 或者为空时，Mutex 的信号量时局部信号量，否则 Mutex 的信号量是命名系统信号量。Semaphore 的话，也是两种方式都有。

如果使用接受名称的构造函数创建 Semaphore 对象，则该对象将与该名称的操作系统信号量关联。

两个构造函数：

```csharp
Semaphore(Int32, Int32, String)
Semaphore(Int32, Int32, String, Boolean)
```

上面的构造函数可以创建多个表示同一命名系统信号量的 Semaphore 对象，并可以使用 OpenExisting 方法打开现有的已命名系统信号量。

我们上面使用的示例就是局部信号量，进程中引用本地 Semaphore 对象的所有线程都可以使用。 每个 Semaphore 对象都是单独的本地信号量。

可以利用 Semaphore 限制一个程序最多能够同时运行多少个。

### Semaphore 类

Semaphore的构造函数如下：

| 构造函数                                 | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| Semaphore(Int32, Int32)                  | 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口数。 |
| Semaphore(Int32, Int32, String)          | 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口数，根据需要指定系统信号灯对象的名称。 |
| Semaphore(Int32, Int32, String, Boolean) | 初始化 Semaphore 类的新实例，并指定初始入口数和最大并发入口数，还可以选择指定系统信号量对象的名称，以及指定一个变量来接收指示是否创建了新系统信号量的值。 |

在`SemaphoreSlim`类的构造方法中，第一个参数定义了最初释放的锁定数，第二个参数定义了锁定个数的计数。如果第一个参数的值小于第二个参数，它们的差就是已经分配线程的计数值。与互斥一样，可以给信号量指定名称，使之在不同的进程之间共享。如果定义信号量时没有指定名称，只能在这个进程中使用。

Semaphore 使用纯粹的内核时间(kernel-time)方式(等待时间很短)，并且支持在不同的进程间同步线程(像Mutex)。

以下述构造函数为例：

```
public Semaphore(int initialCount, int maximumCount);
```

- initialCount 表示一开始允许几个进程进入资源池，如果设置为0，所有线程都不能进入，要一直等资源池放通。

- maximumCount 表示最大允许几个线程进入资源池。

Semaphore 常用方法如下：

| 方法                               | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| Close()                            | 释放由当前 WaitHandle占用的所有资源。                        |
| OpenExisting(String)               | 打开指定名称为信号量（如果已经存在）。                       |
| Release()                          | 退出信号量并返回前一个计数。                                 |
| Release(Int32)                     | 以指定的次数退出信号量并返回前一个计数。                     |
| TryOpenExisting(String, Semaphore) | 打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。 |
| WaitOne()                          | 阻止当前线程，直到当前 WaitHandle 收到信号。                 |
| WaitOne(Int32)                     | 阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。 |
| WaitOne(Int32, Boolean)            | 阻止当前线程，直到当前的 WaitHandle 收到信号为止，同时使用 32 位带符号整数指定时间间隔，并指定是否在等待之前退出同步域。 |
| WaitOne(TimeSpan)                  | 阻止当前线程，直到当前实例收到信号，同时使用 TimeSpan 指定时间间隔。 |
| WaitOne(TimeSpan, Boolean)         | 阻止当前线程，直到当前实例收到信号为止，同时使用 TimeSpan 指定时间间隔，并指定是否在等待之前退出同步域。 |

使用 Semaphore ，有四个步骤：

1. new 实例化 Semaphore，并设置最大线程数、初始化时可进入线程数；
2. 使用 `.WaitOne();` 获取进入权限(在获得进入权限前，线程处于阻塞状态)。
3. 离开时使用 `Release()` 释放占用。
4. `Close()` 释放Semaphore 对象。

#### Semaphore 示例

简单示例：

```csharp
static void Main(string[] args)
{
    for (int i = 0; i < 5; i++)
    {
        new Thread((a) =>
        {
            Console.WriteLine(a + "想要进入资源池");
            //阻塞当前线程，直到收到信号获取到进入权限
            _sem.Wait();
            Console.WriteLine(a + "已经进入");
            Thread.Sleep((int)a * 1000);
            Console.WriteLine(a + "正在离开");
            //可以将此行代码注释看看效果
            _sem.Release();
        }).Start(i);
    }
}
```

运行结果：

```
0想要进入资源池
1想要进入资源池
0已经进入
0正在离开
4想要进入资源池
4已经进入
1已经进入
2想要进入资源池
2已经进入
3想要进入资源池
1正在离开
3已经进入
2正在离开
4正在离开
3正在离开
```

示例二，采用多个线程执行计算，但是只允许最多三个线程同时执行运行。

```csharp
class Program
    {
        // 求和
        private static int sum = 0;
        private static Semaphore _pool;

        // 判断十个线程是否结束了。
        private static int isComplete = 0;
        // 第一个程序
        static void Main(string[] args)
        {
            Console.WriteLine("执行程序");

            // 设置允许最大三个线程进入资源池
            // 一开始设置为0，就是初始化时允许几个线程进入
            // 这里设置为0，后面按下按键时，可以放通三个线程
            _pool = new Semaphore(0, 3);
            for (int i = 0; i < 10; i++)
            {
                Thread thread = new Thread(new ParameterizedThreadStart(AddOne));
                thread.Start(i + 1);
            }
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("任意按下键(不要按关机键)，可以打开资源池");
            Console.ForegroundColor = ConsoleColor.White;
            Console.ReadKey();

            // 准许三个线程进入
            _pool.Release(3);

            // 这里没有任何意义，就单纯为了演示查看结果。
            // 等待所有线程完成任务
            while (true)
            {
                if (isComplete >= 10)
                    break;
                Thread.Sleep(TimeSpan.FromSeconds(1));
            }
            Console.WriteLine("sum = " + sum);

            // 释放池
            _pool.Close();

        }

        public static void AddOne(object n)
        {
            Console.WriteLine($"    线程{(int)n}启动，进入队列");
            // 进入队列等待
            _pool.WaitOne();
            Console.WriteLine($"第{(int)n}个线程进入资源池");
            // 进入资源池
            for (int i = 0; i < 10; i++)
            {
                Interlocked.Add(ref sum, 1);
                Thread.Sleep(TimeSpan.FromMilliseconds(500));
            }
            // 解除占用的资源池
            _pool.Release();
            isComplete += 1;
            Console.WriteLine($"                     第{(int)n}个线程退出资源池");
        }
    }
```

运行效果：

![Semaphoregif](./assets/Semaphoregif.gif)

`Release()` 表示退出信号量并返回前一个计数。这个计数指的是资源池还可以进入多少个线程。

可以看一下下面的示例：

```csharp
private static Semaphore _pool;
static void Main(string[] args)
{
    _pool = new Semaphore(0, 5);
    _pool.Release(5);
    new Thread(AddOne).Start();
    Thread.Sleep(TimeSpan.FromSeconds(10));
    _pool.Close();
}

public static void AddOne()
{
    _pool.WaitOne();
    Thread.Sleep(1000);
    int count = _pool.Release();
    Console.WriteLine("在此线程退出资源池前，资源池还有多少线程可以进入？" + count);
}
```



### SemaphoreSlim 类

SemaphoreSlim 表示对可同时访问资源或资源池的线程数加以限制的 Semaphore 的轻量替代。

SemaphoreSlim 不使用信号量，不支持进程间同步，只能在进程内使用。

它有两个构造函数：

| 构造函数                    | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| SemaphoreSlim(Int32)        | 初始化 SemaphoreSlim 类的新实例，以指定可同时授予的请求的初始数量。 |
| SemaphoreSlim(Int32, Int32) | 初始化 SemaphoreSlim 类的新实例，同时指定可同时授予的请求的初始数量和最大数量。 |

我们改造一下前面 Semaphore 中的示例：

```csharp
    class Program
    {
        // 求和
        private static int sum = 0;
        private static SemaphoreSlim _pool;

        // 判断十个线程是否结束了。
        private static int isComplete = 0;
        static void Main(string[] args)
        {
            Console.WriteLine("执行程序");

            // 设置允许最大三个线程进入资源池
            // 一开始设置为0，就是初始化时允许几个线程进入
            // 这里设置为0，后面按下按键时，可以放通三个线程
            _pool = new SemaphoreSlim(0, 3);
            for (int i = 0; i < 10; i++)
            {
                Thread thread = new Thread(new ParameterizedThreadStart(AddOne));
                thread.Start(i + 1);
            }

            Console.WriteLine("任意按下键(不要按关机键)，可以打开资源池");
            Console.ReadKey();
            // 
            _pool.Release(3);

            // 这里没有任何意义，就单纯为了演示查看结果。
            // 等待所有线程完成任务
            while (true)
            {
                if (isComplete >= 10)
                    break;
                Thread.Sleep(TimeSpan.FromSeconds(1));
            }
            Console.WriteLine("sum = " + sum);
            // 释放池
        }

        public static void AddOne(object n)
        {
            Console.WriteLine($"    线程{(int)n}启动，进入队列");
            // 进入队列等待
            _pool.Wait();
            Console.WriteLine($"第{(int)n}个线程进入资源池");
            // 进入资源池
            for (int i = 0; i < 10; i++)
            {
                Interlocked.Add(ref sum, 1);
                Thread.Sleep(TimeSpan.FromMilliseconds(200));
            }
            // 解除占用的资源池
            _pool.Release();
            isComplete += 1;
            Console.WriteLine($"                     第{(int)n}个线程退出资源池");
        }
    }
```

SemaphoreSlim 不需要 `Close()`。

示例二，来自于《C#高级编程》：

```c#
static void TaskMain(SemaphoreSlim semaphore)
{
    bool isCompleted = false;
    while (!isCompleted)
    {
        //锁定信号量，定义最长等待时间为600毫秒
        if (semaphore.Wait(600))
        {
            try
            {
                Console.WriteLine($"Task {Task.CurrentId} locks the semaphore");
                Task.Delay(2000).Wait();
            }
            finally
            {
                Console.WriteLine($"Task {Task.CurrentId} releases the semaphore");
                semaphore.Release();
                isCompleted = true;
            } 
        }
        else{
            Console.WriteLine($"Timeout for task {Task.CurrentId}; wait again");
        }
    }
}

public static void Run()
{
    int taskCount = 6;
    int semaphoreCount = 3;
    //创建计数为3的信号量
    //该构造函数第一个参数表示最初释放的锁定量，第二个参数定义了锁定个数的计数
    var semaphore = new SemaphoreSlim(semaphoreCount, semaphoreCount);
    var tasks = new Task[taskCount];
    for(int i = 0; i < taskCount; i++)
    {
        tasks[i] = Task.Run(()=>TaskMain(semaphore));
    }

    Task.WaitAll(tasks);
    Console.WriteLine("All tasks finished");
}
```

> 上述代码中的`Run()`方法中，创建了6个任务和一个计数为3的信号量。在`SemaphoreSlim`类的构造方法中，第一个参数定义了最初释放的锁定数，第二个参数定义了锁定个数的计数。如果第一个参数的值小于第二个参数，它们的差就是已经分配线程的计数值。与互斥一样，可以给信号量指定名称，使之在不同的进程之间共享。实例中，定义信号量时没有指定名称，所以它只能在这个进程中使用。
>
> 上述代码中的`TaskMain()`方法中，任务利用`Wait()`方法锁定信号量。信号量的计数是3，所以有3个任务可以获得锁定。第4个任务必须等待，这里还定义了最长等待时间为600毫秒。如果在该等待时间过后未能获得锁定，任务就把一条消息写入控制台，在循环中继续等待。只要获得了锁定，任务就把一条消息写入控制台，等待一段时间，然后解除锁定。在解除锁定时，在任何情况下一定要解除资源的锁定，这一点很重要。这就是要在`finally`处理程序中调用`SemaphoreSlim.Release()`方法的原因。

上述代码执行后，输出结果如下：

```
Task 3 locks the semaphore
Task 2 locks the semaphore
Task 1 locks the semaphore
Timeout for task 4; wait again
Timeout for task 4; wait again
Timeout for task 5; wait again
Timeout for task 4; wait again
Task 1 releases the semaphore
Task 9 locks the semaphore
Task 3 releases the semaphore
Task 5 locks the semaphore
Task 2 releases the semaphore
Task 4 locks the semaphore
Task 4 releases the semaphore
Task 5 releases the semaphore
Task 9 releases the semaphore
All tasks finished
-----程序执行完毕-----
```



### SemaphoreSlim 与 Semaphore 的区别

如果使用下面的构造函数实例化 Semaphore(参数name不能为空)，那么**创建的对象在整个操作系统内都有效**。

```csharp
public Semaphore (int initialCount, int maximumCount, string name);
```

Semaphorslim 则只在进程内有效，SemaphoreSlim 是对 Semaphore 的简单封装。

SemaphoreSlim 类不会对 `Wait`、`WaitAsync` 和 `Release` 方法的调用强制执行线程或任务标识。

而 Semaphor 类，会对此进行严格监控，如果对应调用数量不一致，会出现异常。

此外，如果使用 SemaphoreSlim(Int32 maximumCount) 构造函数来实例化 SemaphoreSlim 对象，获取其 CurrentCount 属性，其值可能会大于 maximumCount。 编程人员应负责确保调用一个 Wait 或 WaitAsync 方法，便调用一个 Release。

这就好像笔筒里面的笔，没有监控，使用这使用完毕后，都应该将笔放进去。如果原先有10支笔，每次使用不放进去，或者将别的地方的笔放进去，那么最后数量就不是10了。因此使用时需要注意捕获异常，合理释放锁。



## 读写锁（ReaderWriterLockSlim，非排它锁）

当某个资源的读操作很多，但写操作很少，此时可以使用读写锁，来最大限度的保证锁的可用性。

ReaderWriterLockSlim 是在 .NET Fx3.5 中引入的，它替代了笨重的ReaderWriterLock类，ReaderWriterLock 和 ReaderWriterLockSlim 具有相似的功能，但是ReaderWriterLock的执行速度更慢，并且本身存在一些锁升级处理机制的设计缺陷。因此实际使用中，应该采用ReaderWriterLockSlim。

与常规的lock（Monitor.Enter/Exit）相比，ReaderWriterLockSlim的执行速度任然慢很多，但是它可以在==大量的读操作和少量写操作==的环境下减少锁竞争。

ReaderWriterLockSlim 和ReaderWriterLock都拥有两种基本的锁，即读锁和写锁：

- 写锁是全局排它锁
- 读锁可以兼容其他的读锁

因此，==一个持有写锁的线程，将阻塞其他任何视图获取读锁或写锁的线程（反之亦然）。但是，如果没有任何线程持有写锁的话，那么其他任意数量的线程都可以并发获得读锁==。

### ReaderWriterLockSlim类

| 方法                                  | 说明                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| EnterReadLock()                       | 尝试进入读取模式锁定状态。                                   |
| EnterUpgradeableReadLock()            | 尝试进入可升级模式锁定状态。                                 |
| EnterWriteLock()                      | 尝试进入写入模式锁定状态。                                   |
| ExitReadLock()                        | 减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。 |
| ExitUpgradeableReadLock()             | 减少可升级模式的递归计数，并在生成的计数为 0（零）时退出可升级模式。 |
| ExitWriteLock()                       | 减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。 |
| TryEnterReadLock(Int32)               | 尝试进入读取模式锁定状态，可以选择整数超时时间。             |
| TryEnterReadLock(TimeSpan)            | 尝试进入读取模式锁定状态，可以选择超时时间。                 |
| TryEnterUpgradeableReadLock(Int32)    | 尝试进入可升级模式锁定状态，可以选择超时时间。               |
| TryEnterUpgradeableReadLock(TimeSpan) | 尝试进入可升级模式锁定状态，可以选择超时时间。               |
| TryEnterWriteLock(Int32)              | 尝试进入写入模式锁定状态，可以选择超时时间。                 |
| TryEnterWriteLock(TimeSpan)           | 尝试进入写入模式锁定状态，可以选择超时时间。                 |

`EnterReadLock()` / `TryEnterReadLock` 和 `ExitReadLock()` 成对出现。

`EnterWriteLock()` / `TryEnterWriteLock()` 和 `ExitWriteLock()` 成对出现。

`EnterUpgradeableReadLock()` 进入可升级的读模式锁定状态。

`EnterReadLock()` 使用 `EnterUpgradeableReadLock()` 进入升级状态，在恰当时间点 通过 `EnterWriteLock()` 进入写模式。（也可以倒过来）

ReaderWriterLockSlim 的读、写入锁模板如下：

```csharp
private static ReaderWriterLockSlim toolLock = new ReaderWriterLockSlim();

// 读
private T Read()
{
    try
    {
        toolLock.EnterReadLock();           // 获取读取锁
        return obj;
    }
    catch { }
    finally
    {
        toolLock.ExitReadLock();            // 释放读取锁
    }
    return default;
}

// 写
public void Write(int key, int value)
{
    try
    {
        //可升级锁只出现在写操作中，目的是为了在同一个原子操作中将读锁转换为写锁。
        toolLock.EnterUpgradeableReadLock();

        try
        {
            toolLock.EnterWriteLock();
            // 
        }
        catch{}
        finally
        {
            toolLock.ExitWriteLock();
        }
    }
    catch { }
    finally
    {
        toolLock.ExitUpgradeableReadLock();
    }
}
```

注意：可升级锁只出现在写操作中，目的是为了在同一个原子操作中将读锁转换为写锁。

可升级锁和读锁的区别：

虽然可升级锁可以和任意数目的读锁并存，但是一次只能获取一个可升级锁。这可以将锁的升级竞争序列化从而避免在升级中出现死锁。

### ReaderWriterLockSlim 的使用示例

下述示例，来自于《C#7.0 核心技术指南》，三个线程将持续读取列表中的元素，另外两个线程每隔100毫秒生成一个随机数写入到列表中：

```c#
internal class Program
{
    static ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();
    static List<int> _items = new List<int>();
    static Random _rand = new Random();

    static void Read()
    {
        while (true)
        {
            _rw.EnterReadLock();
            foreach (int i in _items) Thread.Sleep(10);
            _rw.ExitReadLock();
        }
    }

    static void Write(object threadID)
    {
        while (true)
        {
            int newNumber = GetRandNum(100);
            //升级锁，实现在一个原子操作中奖读锁转换为写锁
            _rw.EnterUpgradeableReadLock();
            //获取写入锁
            _rw.EnterWriteLock();
            _items.Add(newNumber);
            //释放写入锁
            _rw.ExitWriteLock();
            Console.WriteLine("Thread " + threadID + " added " + newNumber);
            //释放升级锁
            _rw.ExitUpgradeableReadLock();
            Thread.Sleep(100);
        }
    }

    static int GetRandNum(int max) { lock (_rand) return _rand.Next(max); }

    private static void Main(string[] args)
    {
        new Thread(Read).Start();
        new Thread(Read).Start();
        new Thread(Read).Start();

        new Thread(Write).Start("A");
        new Thread(Write).Start("B");
    }
}
```



## 使用事件等待句柄（EventWaitHandle）发送信号

EventWaitHandle和上文中的Mutex、Semaphore都派生自WaitHandle抽象类。

```csharp
public class EventWaitHandle : System.Threading.WaitHandle
```

EventWaitHandle又派生出两个子类：

- [System.Threading.AutoResetEvent](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=net-6.0)
- [System.Threading.ManualResetEvent](https://learn.microsoft.com/zh-cn/dotnet/api/system.threading.manualresetevent?view=net-6.0)

事件等待句柄有三种实现：

- AutoResetEvent
- ManualResetEvent(Slim)
- CountdownEvent

前两种基于通用的EventWaitHandle类，它们继承了基类的所有功能。

### 自动线程通知（AutoRestEvent）

AutoResetEvent就像验票机的闸门一样：插入一张票据只允许一个人通过。其名称中的Auto指的是开放的闸机在行人通过后会自动关闭或重置。（微软文档：表示线程同步事件在一个等待线程释放后收到信号时自动重置。）

线程可以调用WaitOne方法在闸机门口等待、阻塞（在闸机前等待，直至闸机开启）；

调用Set方法即向闸机中插入一张票据。

如果有一系列的线程调用了WaitOne，那么它们会在闸机后排队等待。

票据可以来自任何线程，即任何一个能够访问AutoResetEvent对象的非阻塞线程都可以调用Set方法来释放一个阻塞的线程。

可以通过调用其本身的构造函数或其父类EventWaitHandle的构造函数，这两种方式来创建AutoResetEvent对象。

```csharp
var auto = new AutoResetEvent(false);
```

如果在构造器中的参数指定为true，表示立即调用Set方法。

```csharp
var auto = new EventWaitHandle(false, EventResetModel.AutoRest);
```

AutoResetEvent常用方法：

- `WaitOne()` 用来等待另一个线程发送通知。接受一个可选的超时参数，如果在超时时间内没有收到信号，则返回false。可以使用0作为超时时间调用WaitOne来确认一个等待句柄是否处于“开放”状态，并且不会造成调用者阻塞，如果此时AutoResetEvent处于开放状态的话会将状态重置。
- Set()：用来对线程发出通知，插入票据；
- `ReSet()` 用来重置 `AutoResetEvent` 状态；可以无须等待或阻塞就关闭闸机的门（若原本处于开启状态的话）。



示例一，当线程启动后等待另一个线程发送通知：

```c#
EventWaitHandle _waitHandle = new AutoResetEvent(false);
new Thread(() =>
{
    Console.WriteLine("等待中...");
    _waitHandle.WaitOne();                // Wait for notification
    Console.WriteLine("收到通知");
}).Start();

//Thread.Sleep(1000);                  // Pause for a second...
Console.WriteLine("按下回车键发送通知");
Console.ReadLine();
_waitHandle.Set();
Console.ReadLine();
```

==注意：正常情况下，应该是先有人排队再插入票据，也就是说先调用了WaitOne方法，再调用Set方法，但不是强制要求一定要这么做。在没有任何线程等待的情况下调用Set方法会导致句柄一直处于打开状态，直至有线程调用WaitOne方法。另外，在一个没有线程等待的闸机对象上多次重复调用Set方法，并不会导致多个到达的线程一次性都通过，而是只有下一个线程可以通过，而其他的票据（Set方法）就被浪费了。==

示例二，使用多个AutoResetEvent实现双向信号，主线程等待工作线程准备就绪之后再发送信号：

```csharp
private static void TwoWaySignaling()
{
    EventWaitHandle _ready = new AutoResetEvent(false);
    EventWaitHandle _go = new AutoResetEvent(false);
    object _locker = new object();
    string _message = "";

    new Thread(() =>
    {
        while (true)
        {
            //表示我们已经准备好了
            _ready.Set();
            //等待通知
            _go.WaitOne();
            lock (_locker)
            {
                //使用null消息来停止工作线程的运行
                if (_message == null) return;
                Console.WriteLine(_message);
            }
        }
    }).Start();
    //先等到工人准备好
    _ready.WaitOne();
    lock (_locker) _message = "ooo";
    _go.Set();

    _ready.WaitOne();
    lock (_locker) _message = "ahhh";  // Give the worker another message
    _go.Set();

    _ready.WaitOne();
    lock (_locker) _message = null;    // Signal the worker to exit
    _go.Set();
}
```



### 手动线程通知（ManualResetEvent，信号发送结构）

AutoResetEvent 和 ManualResetEvent 十分相似。两者之间的区别，在于前者是自动(Auto)，后者是手动(Manua)。

ManualResetEvent 的作用就像是一个大门。

调用Set方法就开启大门；

并允许任意数目的调用了WaitOne方法的线程通过大门；

而调用Reset方法则会关闭大门。

在大门关闭时调用WaitOne方法会发生阻塞，而当大门再次打开时，线程会立刻释放。

除了这些区别之外，ManualRestEvent的功能和AutoResetEvent是一样的。

ManualResetEvent适用于用一个线程来释放其他所有线程的情形，门一旦开启，其他线程都可以通过。

示例：

```csharp
class Program
{
    private static ManualResetEvent resetEvent = new ManualResetEvent(false);
    static void Main(string[] args)
    {
        new Thread(DoOne).Start();
        // 用于不断向另一个线程发送信号
        while (true)
        {
            Console.ReadKey();
            resetEvent.Set();           // 发生通知，设置终止状态
        }
    }

    public static void DoOne()
    {
        Console.WriteLine("等待中，请发出信号允许我运行");
        resetEvent.WaitOne();

        // 后面的都无效，线程会直接跳过而无需等待
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        resetEvent.WaitOne();
        Console.WriteLine("线程结束");
    }
}
```

#### ManualResetEventSlim

.NET 4.0 引入了一种新的 ManualResetEvent称为 ManualResetEventSlim。后者对短时期的等待进行了优化。即选择进行几个迭代的自旋操作。此外，它还拥有更加高效的托管实现。并支持在Wait时使用CancellationToken取消等待操作。但是它不能进行跨进程的信号发送。ManualResetEventSlim并没有从WaitHandle中派生，但是它拥有一个WaitHandle属性，访问该属性将返回一个（使用传统等待句柄性能配置的）WaitHandle派生类型的对象。



### 线程完成数（CountdownEvent，信号发送结构）

ManualResetEvent适用于用一个线程来释放其他所有线程的情形，而CountdownEvent则适用于其相反的情形。

CountdownEvent 可用于等待多个线程。若使用该类，需要在实例化时指定线程数目或者需要等待的线程“计数”。

```c#
var  countdown = new CountdownEvent (3);
```

调用 Signal 会使计数递减，而调用 Wait 则会阻塞，直至计数减为零。

调用AddCount方法可以重新增加CountdownEvent的计数，但是如果它的计数已经降为0，则调用该方法会抛出异常：我们无法通过调用AddCount来取消CountdownEvent的信号。为了避免抛出异常，还可以使用TryAddCount，若计数值为0，则该方法返回false。

调用Reset方法可以取消计数事件的信号：它不但取消信号，而且会将计数值重置为原始设定值。

```c#
//等待三个线程
static CountdownEvent _countdown = new CountdownEvent(3);
static void Main(string[] args)
{
    new Thread(SaySomething).Start("第一个线程");
    new Thread(SaySomething).Start("第二个线程");
    new Thread(SaySomething).Start("第三个线程");
    //等待CountdownEvent的计数清零
    _countdown.Wait();   // Blocks until Signal has been called 3 times
    Console.WriteLine("所有的线程都结束运行!");
    Console.ReadLine();
}
static void SaySomething(object thing)
{
    Console.WriteLine(thing);
    Console.ReadLine();
    Console.WriteLine(thing + "按下回车键结束运行");
    // 通知可以减少一个线程的等待了将CountdownEvent计数减一
    _countdown.Signal();
}
```

注意：优先使用PLINQ和Parallel类，再使用CountdownEvent。



### 信号发送结构的性能

- 在无阻塞的情况下，等待或激活一个AutoResetEvent 或者 ManualResetEvent对象需要消耗一微秒的时间。
- 在短暂的等待中，ManualResetEventSlim 和 CountdownEvent的速度要快50倍，因为他们不依赖操作系统，并且谨慎的使用了自旋结构。
- 在大多数情况下，信号发送类本身的开销并不会形成瓶颈，因此很少需要特意进行考虑。



### AutoResetEvent 和 ManualResetEvent 区别（待整理）

ManualResetEvent 发送信号后，信号状态会设置为True，也就是此时程序只要执行到WaitOne()就会接收到信号，只有调用Reset的时候信号状态才会被设置为False 。而AutoResetEvent调用WaitOne将信号状态会设置为True后会自动调用Reset，将非信号状态立即设置为False，如果此时有WaitOne函数在等待信号，则会执行，之后的WaitOne则不会接收到信号。

概括来说，Manual与Auto的区别主要在于：

1. 如果有多个线程都在用WaitOne等待信号量，那么每次Set()，auto只会释放一个WaitOne，而manual会全部释放
2. 调用WaitOne后，auto会自动调用Reset()方法，而manual则会保持开放



ManualResetEvent在创建的时候可以设置信号状态

 ManualResetEvent manualResetEvent = new ManualResetEvent(false); 

ManualResetEvent.WaitOne()作用是等待信号到达，如果没有信号就会让线程再此等待，简单说就是信号状态为True的时候才会继续执行，信号状态为False时，线程会卡在这里 

ManualResetEvent.Set() 发就是将信号状态设置为true，也就是会让WaitOne能够接受信号 ManualResetEvent.Reset()，将信号状态设置为False，也就是设置为非信号状态 





### 并行协调（Barrier ，信号发送结构）

Barrier类实现了一个线程执行屏障（thread execution Barrier），Barrier允许多个线程在同一时刻汇合，使得多个线程有序同步完成多个阶段的任务。

对于同步，`Barrier`类非常适用于其中工作有多个任务分支且以后又需要合并工作的情况。`Barrier`类用于需要同步的参与者。激活一个任务时，就可以动态的添加其他参与者。

`Barrier`类型提供了一个更复杂的场景，其中可以同时运行多个任务，直到达到一个同步点为止。一旦所有任务达到这一点，他们j就可以继续同时满足于下一个同步点。

应用场景主要是控制 N 个线程(可随时增加或减少执行的线程)，使得多线程在能够在 M 个阶段中保持同步。

示例，实现3个线程都会打印从0到4的数字，并与其他线程保持步调一致：

```csharp
static Barrier _barrier = new Barrier(3, barrier => Console.WriteLine());
static void Speak()
{
    for (int i = 0; i < 5; i++)
    {
        Console.Write(i + " ");
        _barrier.SignalAndWait();
    }
}
static void Main(string[] args)
{
    new Thread(Speak).Start();
    new Thread(Speak).Start();
    new Thread(Speak).Start();
}
```

![image-20240301102731503](./assets/image-20240301102731503.png)

上述代码中，使用3作为参数创建Barrier实例，则需要调用3次SignalAndWait方法才能够解除阻塞。

在阻塞解除之后它会重新“轮回”：即再次调用SignalAndWait方法会令其重新进入阻塞状态，而这个阻塞状态需要再调用3次SignalAndWait才能解除。这样就可以令各个线程都步调一致的执行。

创建Barrier对象时还可以指定一个后续操作，该操作是一个委托，==它会在SignalAndWait调用n次之后，所有线程释放之前执行==。



## WaitHandle抽象类

`WaitHandle`是一个抽象基类，用于等待一个信号的设置。可以等待不同的信号，因为`WaitHandle`是一个基类，可以从中派生一些其他类。

上述中的`Mutex`、`Semaphore`和`EventWaitHandle`类都派生自`WaitHandle`基类。

异步委托的`BeginInvoke()`方法返回一个实现了`IAsycResult`接口的对象。使用`IAsycResult`接口，可以用`AsycWaitHandle`属性访问`WaitHandle`基类。在调用`WaitHandle`的`WaitOne()`方式或者超时发生是，线程会等待接收一个与等待句柄相关的信号。调用`EndInvoke()`方法，线程最终会阻塞，知道得到结果为止。

示例如下：

```c#
static int TakesAWhile(int x,int ms)
{
    Task.Delay(ms).Wait();
    return 42;
}
delegate int TakesAWhileDelegate(int x, int ms);
public static void Run()
{
    TakesAWhileDelegate d1 = TakesAWhile;
    IAsyncResult ar= d1.BeginInvoke(1, 3000, null, null);
    while (true)
    {
        if (ar.AsyncWaitHandle.WaitOne(50))
        {
            Console.WriteLine("Can get the result now");
            break;
        }
    }
    int result = d1.EndInvoke(ar);
    Console.WriteLine("result:"+result);
}
```

调用上述方法，输出结果如下：

```
Can get the result now
result:42
-----程序执行完毕-----
```

> 使用`WaitHandle`基类可以等待一个信号的出现（`WaitOne()`方法）、等待必须发出信号的多个对象（`WaitAll()`方法），或者等待多个对象中的一个（`WaitAny()`方法）。`WaitAll()`和`WaitAny()`是`WaitHandle`类的静态方法，接收一个`WaitHandle`参数数组。
>
> `WaitHandle`基类有一个`SafeWaitHandle`属性，其中可以将一个本机句柄赋予一个操作系统资源，并等待该句柄。例如，可以指定一个`SafeFileHandle`等待文件I/O操作的完成。

因为`Mutex`、`EventWaitHandle`和`Semaphore`类派生自`WaitHandle`基类，所以可以在等待时使用它们。











----



References：

- 《C# 7.0 核心技术指南》
- 《C#高级编程（第10版）》
- [2. 线程同步 · C# 多线程与异步](https://threads.whuanle.cn/2.thread_sync/)

Last updated：2025-07-25





